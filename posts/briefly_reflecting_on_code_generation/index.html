<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Briefly reflecting on code generation | 1pkg dev blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Not so long ago I&rsquo;ve been working on Go CLI meta-tool gofire that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by python-fire.
I consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way.">
<meta name="author" content="Kostiantyn Masliuk">
<link rel="canonical" href="https://1pkg.github.io/posts/briefly_reflecting_on_code_generation/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ef101b82f5d0f216577b2b1b33ac59cbf6ec31115df5bcc763ade95cf25496d5.css" integrity="sha256-7xAbgvXQ8hZXeysbM6xZy/bsMRFd9bzHY63pXPJUltU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://1pkg.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://1pkg.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://1pkg.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://1pkg.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://1pkg.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />
<meta property="og:title" content="Briefly reflecting on code generation" />
<meta property="og:description" content="Not so long ago I&rsquo;ve been working on Go CLI meta-tool gofire that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by python-fire.
I consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1pkg.github.io/posts/briefly_reflecting_on_code_generation/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-19T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-01-19T00:00:00&#43;00:00" /><meta property="og:site_name" content="1pkg dev blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Briefly reflecting on code generation"/>
<meta name="twitter:description" content="Not so long ago I&rsquo;ve been working on Go CLI meta-tool gofire that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by python-fire.
I consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://1pkg.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Briefly reflecting on code generation",
      "item": "https://1pkg.github.io/posts/briefly_reflecting_on_code_generation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Briefly reflecting on code generation",
  "name": "Briefly reflecting on code generation",
  "description": "Not so long ago I\u0026rsquo;ve been working on Go CLI meta-tool gofire that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by python-fire.\nI consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way.",
  "keywords": [
    
  ],
  "articleBody": "Not so long ago I’ve been working on Go CLI meta-tool gofire that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by python-fire.\nI consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way.\nFirst and foremost, code generation indeed delivers great predictability to end users. It fundamentally grants better dependencies control over the code, by making generated code to be a part of your project directly and explicitly. Thus moving ownership of the code a bit closer to you. Which makes it easier to read and modify it if needed.\nHowever, simplicity and performance parts are not coming along with each other that well. It’s hard enough to write clean and performant code on its own, but generating clean and performant code is exponentially harder. Because of indirect nature of code generation and lack of good standard tools for writing code that generates code, you more often than not will appear in a situation of stitching together several string buffers containing generated code to then try to quickly compile and simulate it somehow. Which often leads to situations when some corners are getting cut especially if certain flexibility is required in generation process. Therefore trading clean and performant code for simplicity of generation.\nFor sure Go is a great language to be code generated. The language is super explicit, it strives for simple semantics and syntax and it usually has the only one way of doing anything inside which are all handy properties for code generation. Go also provides built in packages to format generated code in a standard way. However unfortunately, it’s where codegen story ends in Go. There is no clear way defined in Go standard library to support code generation to this day. In the wild in most cases you’ll find just strings manipulations used, in other cases you’ll see usage of templates, but usually that’s about it. These approaches to codegen are less than ideal and make the process unnecessary painful. There are some libraries outside of stdlib that could somewhat alleviate this pain, like jennifer.\nTo summarize, code generation is an old valuable technique that is easy to learn but hard to master. Which usually undeservedly doesn’t get enough attention, but along with that it is a great tool in certain situations.\n",
  "wordCount" : "432",
  "inLanguage": "en",
  "datePublished": "2022-01-19T00:00:00Z",
  "dateModified": "2022-01-19T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Kostiantyn Masliuk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://1pkg.github.io/posts/briefly_reflecting_on_code_generation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "1pkg dev blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://1pkg.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://1pkg.github.io" accesskey="h" title="~ (Alt + H)">~</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Briefly reflecting on code generation
    </h1>
    <div class="post-meta">January 19, 2022&nbsp;·&nbsp;Kostiantyn Masliuk
</div>
  </header> 
  <div class="post-content"><p>Not so long ago I&rsquo;ve been working on Go CLI meta-tool <a href="https://github.com/1pkg/gofire">gofire</a> that actively uses code generation. The tool was designed to automatically generate a command line interface for Go functions and do all required plumbing in between. The tool was inspired by <a href="https://github.com/google/python-fire">python-fire</a>.</p>
<p>I consciously chose code generation over any other alternatives because of guarantees of simplicity, predictability and performance. And while I like the results I was able to achieve using it for this project, yet I hit a dozen of common pitfals on my way.</p>
<p>First and foremost, code generation indeed delivers great predictability to end users. It fundamentally grants better dependencies control over the code, by making generated code to be a part of your project directly and explicitly. Thus moving ownership of the code a bit closer to you. Which makes it easier to read and modify it if needed.</p>
<p>However, simplicity and performance parts are not coming along with each other that well. It&rsquo;s hard enough to write clean and performant code on its own, but generating clean and performant code is exponentially harder. Because of indirect nature of code generation and lack of good standard tools for writing code that generates code, you more often than not will appear in a situation of stitching together several string buffers containing generated code to then try to quickly compile and simulate it somehow. Which often leads to situations when some corners are getting cut especially if certain flexibility is required in generation process. Therefore trading clean and performant code for simplicity of generation.</p>
<p>For sure Go is a great language to be code generated. The language is super explicit, it strives for simple semantics and syntax and it usually has the only one way of doing anything inside which are all handy properties for code generation. Go also provides built in <a href="https://pkg.go.dev/golang.org/x/tools/imports">packages</a> to format generated code in a standard way. However unfortunately, it&rsquo;s where codegen story ends in Go. There is no clear way defined in Go standard library to support code generation to this day. In the wild in most cases you&rsquo;ll find just strings manipulations used, in other cases you&rsquo;ll see usage of <a href="https://pkg.go.dev/text/template">templates</a>, but usually that&rsquo;s about it. These approaches to codegen are less than ideal and make the process unnecessary painful. There are some libraries outside of stdlib that could somewhat alleviate this pain, like <a href="https://github.com/dave/jennifer">jennifer</a>.</p>
<p>To summarize, code generation is an old valuable technique that is easy to learn but hard to master. Which usually undeservedly doesn&rsquo;t get enough attention, but along with that it is a great tool in certain situations.</p>


  </div>
  <footer class="post-footer">
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2022 <a href="https://1pkg.github.io">1pkg dev blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
