<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Writing complex concurrent table driven tests | 1pkg dev blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Recently, I&rsquo;ve finished my reading of &ldquo;Software Engineering at Google&rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn&rsquo;t go very deep with any given topic. Rather, it&rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers.">
<meta name="author" content="Kostiantyn Masliuk">
<link rel="canonical" href="https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ef101b82f5d0f216577b2b1b33ac59cbf6ec31115df5bcc763ade95cf25496d5.css" integrity="sha256-7xAbgvXQ8hZXeysbM6xZy/bsMRFd9bzHY63pXPJUltU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://1pkg.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://1pkg.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://1pkg.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://1pkg.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://1pkg.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />
<meta property="og:title" content="Writing complex concurrent table driven tests" />
<meta property="og:description" content="Recently, I&rsquo;ve finished my reading of &ldquo;Software Engineering at Google&rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn&rsquo;t go very deep with any given topic. Rather, it&rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-21T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-03-21T00:00:00&#43;00:00" /><meta property="og:site_name" content="1pkg dev blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Writing complex concurrent table driven tests"/>
<meta name="twitter:description" content="Recently, I&rsquo;ve finished my reading of &ldquo;Software Engineering at Google&rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn&rsquo;t go very deep with any given topic. Rather, it&rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://1pkg.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Writing complex concurrent table driven tests",
      "item": "https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Writing complex concurrent table driven tests",
  "name": "Writing complex concurrent table driven tests",
  "description": "Recently, I\u0026rsquo;ve finished my reading of \u0026ldquo;Software Engineering at Google\u0026rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn\u0026rsquo;t go very deep with any given topic. Rather, it\u0026rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers.",
  "keywords": [
    
  ],
  "articleBody": "Recently, I‚Äôve finished my reading of ‚ÄúSoftware Engineering at Google‚Äù book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn‚Äôt go very deep with any given topic. Rather, it‚Äôs just quite nicely composed collection of easy to read and understand thoughts from Google engineers.\nOne subject highlighted in this book got me thinking more than others - testing. The book spends quite some time on it, having sections: ‚ÄúTesting Overview‚Äù, ‚ÄúUnit Testing‚Äù, ‚ÄúTest Doubles‚Äù, ‚ÄúLarger Testing‚Äù, etc. And while most of the points given by the authors here are 100% undeniable:\n ‚Äúfollow proper ratio between unit/integration/e2e tests 80/15/5 (also known as test pyramid)\"; ‚Äútest everything that is important for your application, i.e. anything that brings you the value directly or indirectly (so-called Beyonc√© rule)\"; ‚Äúdo not over use mocks, prefer to use real implementation instead (test behavior not methods)\"; ‚Äútry to avoid having brittle tests as much as you can (in the long run they might appear to be a big problem)\"; ‚Äúaim for simplest possible test, try to not use any logic inside your tests‚Äù; and so much more other useful and practical advices;  It‚Äôs definitely worth to say that all of these advices are not ultimate truth and specific needs of specific systems could outweigh them easily.\nNot so long ago, I was adding quite complex test suites for one of my open source projects throttler library gohalt. Originally, I underestimated this task, thinking: ‚Äúhow hard it would be to add some decent test coverage to project that is already well prepared to be tested (it has one core throttler interface and 30+ throttlers implementations) ‚Ä¶ it should be super easy to use test table here, right?‚Äù. I was horribly wrong ü§™. For the beginning, we need to understand that logically all throttlers are used in concurrent muli-threading environments (otherwise, why would you use throttlers in the first place). Therefore, tests for thottlers require to have heavy concurrent testing workload; otherwise they provide test scenarios far from reallity and generally have value close to zero. But one does not simply - to have one test table to rule all throttlers that act differently and need radically different setup for concurrent workload.\nWhat does ‚ÄúSoftware Engineering at Google‚Äù book suggest to do in such case scenario? I believe majority of readers will answer the rule still stands ‚Äúdo not add any complex logic inside you test‚Äù. But then we have only single choice here: ditch out nice table driven testing approach and use separate test case scenario for each trottler with separate setup helper for each test case respectively. Although this approach is sound on paper, for gohalt it has single fatal flow - the amount of testing boilerplates will be outstading. It‚Äôs hard to say with certainty how much testing code will be needed. But my expectations are that amout of testing code will be at least double amount of actual project code itself üòÆ maybe even more. While it might be acceptable and even preferable to someone to have huge, verbose but very explicit test suite, I decided to cheat a bit and go smart on this instead. I went with using table driven testing approach with separate ‚Äúovercomplicated‚Äù test case setup structure for any given test case full gohalt test code.\nLet‚Äôs look on resulting code briefly.\nvar trun Runner = NewRunnerSync(context.Background(), NewThrottlerBuffered(1)) type tcase struct { tms uint64 // number of sub runs inside one case \tthr Throttler // throttler itself \tacts []Runnable // actions that need to be throttled \tpres []Runnable // actions that neeed to be run before throttle \ttss []time.Duration // timestamps that needs to be applied to contexts set \tctxs []context.Context // contexts set for throttling \terrs []error // expected throttler errors \tdurs []time.Duration // expected throttler durations \tidx uint64 // carries seq number of sub run execution \tover bool // if throttler needs to be over released \tpass bool // if throttler doesn't need to be released \twait time.Duration // if next throttler run needs to be delayed in acq } func (t *tcase) run(index int) (dur time.Duration, err error) { // get context with fallback \tctx := context.Background() if index t.ctxs) { ctx = t.ctxs[index] } // run additional pre action only if present \tif index t.pres) { if pre := t.pres[index]; pre != nil { _ = pre(ctx) } } var ts time.Time // try catch panic into error \tfunc() { defer atomicIncr(\u0026t.idx) defer func() { if msg := recover(); msg != nil { err = msg.(ErrorInternal) } }() ts = time.Now() // force strict acquire order \tfor index != int(atomicGet(\u0026t.idx)) { _ = sleep(ctx, time.Microsecond) } // set additional timestamp only if present \tif index t.tss) { ctx = WithTimestamp(ctx, time.Now().Add(t.tss[index])) } err = t.thr.Acquire(ctx) // in case of threshold error \tif terr, ok := err.(ErrorThreshold); ok { // check whether it's durations threshold \tif durs, ok := terr.Threshold.(strdurations); ok { // then round current values to milliseconds \tdurs.current = durs.current.Round(time.Millisecond) terr.Threshold = durs err = terr } } // if next throttler run needs to be delayed sleep for wait \tif t.wait  0 { _ = sleep(ctx, t.wait) } }() dur = time.Since(ts) // run additional action only if present \tif index t.acts) { if act := t.acts[index]; act != nil { _ = act(ctx) } } limit := 1 if t.over \u0026\u0026 uint64(index+1) == t.tms { // imitate over releasing on last call \tlimit = index + 1 } if t.pass { limit = 0 } for i := 0; i limit; i++ { if err := t.thr.Release(ctx); err != nil { return dur, err } } return } func (t *tcase) result(index int) (dur time.Duration, err error) { if index t.errs) { err = t.errs[index] } if index t.durs) { dur = t.durs[index] } return } Structure tcase represents single test case data set for any given throttler. It flexibly configures what actions should be applied to the throttler, how many times, in which order, with what extra options and what results should we expect after this. The main idea here - for each test case to define how many parallel concurrent calls needs to be applied to the throttler tms; to define ordered lists of actions acts and pres to be executed on the throttler; to define ordered lists of options that need to be propagated to the throttler tss, ctxs; define global options for the run over, pass, wait; and finally to define ordered lists of result expectations errs, durs. To ensure strict ordering, simple spin lock like technique is used.\nfunc() { defer atomicIncr(\u0026t.idx) // force strict acquire order \tfor index != int(atomicGet(\u0026t.idx)) { _ = sleep(ctx, time.Microsecond) } err = t.thr.Acquire(ctx) }() The heart of test routine itself is placed inside main test entry point loop.\nfunc TestThrottlers(t *testing.T) { table := map[string]tcase{ // code here is omitted \t} for tname, ptrtcase := range table { t.Run(tname, func(t *testing.T) { var wg sync.WaitGroup wg.Add(int(ptrtcase.tms)) for i := 0; i ptrtcase.tms); i++ { t.Run(fmt.Sprintf(\"run %d\", i+1), func(t *testing.T) { go func(index int, tcase *tcase) { defer wg.Done() rdur, rerr := tcase.result(index) dur, err := tcase.run(index) trun.Run(func(context.Context) error { log(\"expected error %v actual err %v\", rerr, err) log(\"expected duration le %s actual duration %s\", rdur/2, dur) require.Equal(t, rerr, err) require.LessOrEqual(t, int64(rdur/2), int64(dur)) return nil }) }(i, \u0026ptrtcase) }) } wg.Wait() }) } } Nothing super fancy happens here; we iterate over test cases table and run them one by one. Note two things though: first we cannot use t.Parallel runner here as we need strict control over execution ordering for a sinlgle test case and second we are using approximate comparison of resulting durations require.LessOrEqual(t, int64(rdur/2), int64(dur)) to reduce test brittleness.\nI acknowledge that this code is far from masterpiece. Moreover, it even fails occasionally (from my experience false positive rate is less than couple percents) which could be resolved by further adjusting comparison durations threshold and tuning individual test cases. But overal, this code works great and it helped me to reduce test helper boilerplates to the bare minimum.\nInstead of any conclusion, I want to provide some numbers for gohalt tests. The ratio of test setup helper code to real test case scenarios is approximately 1:7. The ratio of test code to library code itself is an approximately 1:1 while vast majority of all code is fully covered. I highly doubt that the same amount of tests with the same coverage could be possible if the rule of simple tests was followed. So, as always, don‚Äôt follow any Software Engineering dogma blindly, think what suits your situation best and stay tuned for more reading!\n",
  "wordCount" : "1474",
  "inLanguage": "en",
  "datePublished": "2021-03-21T00:00:00Z",
  "dateModified": "2021-03-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Kostiantyn Masliuk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "1pkg dev blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://1pkg.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://1pkg.github.io" accesskey="h" title="~ (Alt + H)">~</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Writing complex concurrent table driven tests
    </h1>
    <div class="post-meta">March 21, 2021&nbsp;¬∑&nbsp;Kostiantyn Masliuk
</div>
  </header> 
  <div class="post-content"><p>Recently, I&rsquo;ve finished my reading of &ldquo;Software Engineering at Google&rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn&rsquo;t go very deep with any given topic. Rather, it&rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers.</p>
<p>One subject highlighted in this book got me thinking more than others - testing. The book spends quite some time on it, having sections: &ldquo;Testing Overview&rdquo;, &ldquo;Unit Testing&rdquo;, &ldquo;Test Doubles&rdquo;, &ldquo;Larger Testing&rdquo;, etc. And while most of the points given by the authors here are 100% undeniable:</p>
<ul>
<li>&ldquo;follow proper ratio between unit/integration/e2e tests 80/15/5 (also known as test pyramid)&quot;;</li>
<li>&ldquo;test everything that is important for your application, i.e. anything that brings you the value directly or indirectly (so-called Beyonc√© rule)&quot;;</li>
<li>&ldquo;do not over use mocks, prefer to use real implementation instead (test behavior not methods)&quot;;</li>
<li>&ldquo;try to avoid having brittle tests as much as you can (in the long run they might appear to be a big problem)&quot;;</li>
<li>&ldquo;aim for simplest possible test, try to not use any logic inside your tests&rdquo;;</li>
<li>and so much more other useful and practical advices;</li>
</ul>
<p>It&rsquo;s definitely worth to say that all of these advices are not ultimate truth and specific needs of specific systems could outweigh them easily.</p>
<p>Not so long ago, I was adding quite complex test suites for one of my open source projects throttler library <a href="https://github.com/1pkg/gohalt">gohalt</a>. Originally, I underestimated this task, thinking: &ldquo;how hard it would be to add some decent test coverage to project that is already well prepared to be tested (it has one core throttler interface and 30+ throttlers implementations) &hellip; it should be super easy to use test table here, right?&rdquo;. I was horribly wrong ü§™. For the beginning, we need to understand that logically all throttlers are used in concurrent muli-threading environments (otherwise, why would you use throttlers in the first place). Therefore, tests for thottlers require to have heavy concurrent testing workload; otherwise they provide test scenarios far from reallity and generally have value close to zero. But one does not simply - to have one test table to rule all throttlers that act differently and need radically different setup for concurrent workload.</p>
<p>What does &ldquo;Software Engineering at Google&rdquo; book suggest to do in such case scenario? I believe majority of readers will answer the rule still stands &ldquo;do not add any complex logic inside you test&rdquo;. But then we have only single choice here: ditch out nice table driven testing approach and use separate test case scenario for each trottler with separate setup helper for each test case respectively. Although this approach is sound on paper, for <code>gohalt</code> it has single fatal flow - the amount of testing boilerplates will be outstading. It&rsquo;s hard to say with certainty how much testing code will be needed. But my expectations are that amout of testing code will be at least double amount of actual project code itself üòÆ maybe even more. While it might be acceptable and even preferable to someone to have huge, verbose but very explicit test suite, I decided to cheat a bit and go smart on this instead. I went with using table driven testing approach with separate &ldquo;overcomplicated&rdquo; test case setup structure for any given test case <a href="https://github.com/1pkg/gohalt/blob/master/throttlers_test.go">full gohalt test code</a>.</p>
<p>Let&rsquo;s look on resulting code briefly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">trun</span> <span style="color:#a6e22e">Runner</span> = <span style="color:#a6e22e">NewRunnerSync</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">NewThrottlerBuffered</span>(<span style="color:#ae81ff">1</span>))

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tcase</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">tms</span>  <span style="color:#66d9ef">uint64</span>            <span style="color:#75715e">// number of sub runs inside one case
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">thr</span>  <span style="color:#a6e22e">Throttler</span>         <span style="color:#75715e">// throttler itself
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">acts</span> []<span style="color:#a6e22e">Runnable</span>        <span style="color:#75715e">// actions that need to be throttled
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pres</span> []<span style="color:#a6e22e">Runnable</span>        <span style="color:#75715e">// actions that neeed to be run before throttle
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">tss</span>  []<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>   <span style="color:#75715e">// timestamps that needs to be applied to contexts set
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ctxs</span> []<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span> <span style="color:#75715e">// contexts set for throttling
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">errs</span> []<span style="color:#66d9ef">error</span>           <span style="color:#75715e">// expected throttler errors
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">durs</span> []<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>   <span style="color:#75715e">// expected throttler durations
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">idx</span>  <span style="color:#66d9ef">uint64</span>            <span style="color:#75715e">// carries seq number of sub run execution
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">over</span> <span style="color:#66d9ef">bool</span>              <span style="color:#75715e">// if throttler needs to be over released
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pass</span> <span style="color:#66d9ef">bool</span>              <span style="color:#75715e">// if throttler doesn&#39;t need to be released
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">wait</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>     <span style="color:#75715e">// if next throttler run needs to be delayed in acq
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tcase</span>) <span style="color:#a6e22e">run</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">dur</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#75715e">// get context with fallback
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">ctxs</span>) {
		<span style="color:#a6e22e">ctx</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">ctxs</span>[<span style="color:#a6e22e">index</span>]
	}
	<span style="color:#75715e">// run additional pre action only if present
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pres</span>) {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pre</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pres</span>[<span style="color:#a6e22e">index</span>]; <span style="color:#a6e22e">pre</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">pre</span>(<span style="color:#a6e22e">ctx</span>)
		}
	}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ts</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
	<span style="color:#75715e">// try catch panic into error
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">atomicIncr</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">idx</span>)
		<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">msg</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">msg</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">msg</span>.(<span style="color:#a6e22e">ErrorInternal</span>)
			}
		}()
		<span style="color:#a6e22e">ts</span> = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
		<span style="color:#75715e">// force strict acquire order
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">!=</span> int(<span style="color:#a6e22e">atomicGet</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">idx</span>)) {
			<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">sleep</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Microsecond</span>)
		}
		<span style="color:#75715e">// set additional timestamp only if present
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">tss</span>) {
			<span style="color:#a6e22e">ctx</span> = <span style="color:#a6e22e">WithTimestamp</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">tss</span>[<span style="color:#a6e22e">index</span>]))
		}
		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">thr</span>.<span style="color:#a6e22e">Acquire</span>(<span style="color:#a6e22e">ctx</span>)
		<span style="color:#75715e">// in case of threshold error
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">terr</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#a6e22e">ErrorThreshold</span>); <span style="color:#a6e22e">ok</span> {
			<span style="color:#75715e">// check whether it&#39;s durations threshold
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">durs</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">terr</span>.<span style="color:#a6e22e">Threshold</span>.(<span style="color:#a6e22e">strdurations</span>); <span style="color:#a6e22e">ok</span> {
				<span style="color:#75715e">// then round current values to milliseconds
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">durs</span>.<span style="color:#a6e22e">current</span> = <span style="color:#a6e22e">durs</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">Round</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
				<span style="color:#a6e22e">terr</span>.<span style="color:#a6e22e">Threshold</span> = <span style="color:#a6e22e">durs</span>
				<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">terr</span>
			}
		}
		<span style="color:#75715e">// if next throttler run needs to be delayed sleep for wait
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wait</span> &gt; <span style="color:#ae81ff">0</span> {
			<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">sleep</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">wait</span>)
		}
	}()
	<span style="color:#a6e22e">dur</span> = <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Since</span>(<span style="color:#a6e22e">ts</span>)
	<span style="color:#75715e">// run additional action only if present
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">acts</span>) {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">act</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">acts</span>[<span style="color:#a6e22e">index</span>]; <span style="color:#a6e22e">act</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">act</span>(<span style="color:#a6e22e">ctx</span>)
		}
	}
	<span style="color:#a6e22e">limit</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">over</span> <span style="color:#f92672">&amp;&amp;</span> uint64(<span style="color:#a6e22e">index</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">tms</span> { <span style="color:#75715e">// imitate over releasing on last call
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">limit</span> = <span style="color:#a6e22e">index</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">pass</span> {
		<span style="color:#a6e22e">limit</span> = <span style="color:#ae81ff">0</span>
	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">limit</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">thr</span>.<span style="color:#a6e22e">Release</span>(<span style="color:#a6e22e">ctx</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dur</span>, <span style="color:#a6e22e">err</span>
		}
	}
	<span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tcase</span>) <span style="color:#a6e22e">result</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">dur</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Duration</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">errs</span>) {
		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">errs</span>[<span style="color:#a6e22e">index</span>]
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">index</span> &lt; len(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">durs</span>) {
		<span style="color:#a6e22e">dur</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">durs</span>[<span style="color:#a6e22e">index</span>]
	}
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><p>Structure <code>tcase</code> represents single test case data set for any given throttler. It flexibly configures what actions should be applied to the throttler, how many times, in which order, with what extra options and what results should we expect after this. The main idea here - for each test case to define how many parallel concurrent calls needs to be applied to the throttler <code>tms</code>; to define ordered lists of actions <code>acts</code> and <code>pres</code> to be executed on the throttler; to define ordered lists of options that need to be propagated to the throttler <code>tss</code>, <code>ctxs</code>; define global options for the run <code>over</code>, <code>pass</code>, <code>wait</code>; and finally to define ordered lists of result expectations <code>errs</code>, <code>durs</code>. To ensure strict ordering, simple spin lock like technique is used.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">atomicIncr</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">idx</span>)
		<span style="color:#75715e">// force strict acquire order
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">!=</span> int(<span style="color:#a6e22e">atomicGet</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">idx</span>)) {
			<span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">sleep</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Microsecond</span>)
		}
		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">thr</span>.<span style="color:#a6e22e">Acquire</span>(<span style="color:#a6e22e">ctx</span>)
	}()
</code></pre></div><p>The heart of test routine itself is placed inside main test entry point loop.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestThrottlers</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
	<span style="color:#a6e22e">table</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">tcase</span>{
		<span style="color:#75715e">// code here is omitted
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">tname</span>, <span style="color:#a6e22e">ptrtcase</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">table</span> {
		<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">tname</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(int(<span style="color:#a6e22e">ptrtcase</span>.<span style="color:#a6e22e">tms</span>))
			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; int(<span style="color:#a6e22e">ptrtcase</span>.<span style="color:#a6e22e">tms</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
				<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;run %d&#34;</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
					<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">index</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">tcase</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tcase</span>) {
						<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
						<span style="color:#a6e22e">rdur</span>, <span style="color:#a6e22e">rerr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tcase</span>.<span style="color:#a6e22e">result</span>(<span style="color:#a6e22e">index</span>)
						<span style="color:#a6e22e">dur</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tcase</span>.<span style="color:#a6e22e">run</span>(<span style="color:#a6e22e">index</span>)
						<span style="color:#a6e22e">trun</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">error</span> {
							<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;expected error %v actual err %v&#34;</span>, <span style="color:#a6e22e">rerr</span>, <span style="color:#a6e22e">err</span>)
							<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;expected duration le %s actual duration %s&#34;</span>, <span style="color:#a6e22e">rdur</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">dur</span>)
							<span style="color:#a6e22e">require</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">rerr</span>, <span style="color:#a6e22e">err</span>)
							<span style="color:#a6e22e">require</span>.<span style="color:#a6e22e">LessOrEqual</span>(<span style="color:#a6e22e">t</span>, int64(<span style="color:#a6e22e">rdur</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>), int64(<span style="color:#a6e22e">dur</span>))
							<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
						})
					}(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ptrtcase</span>)
				})
			}
			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
		})
	}
}
</code></pre></div><p>Nothing super fancy happens here; we iterate over test cases table and run them one by one. Note two things though: first we cannot use t.Parallel runner here as we need strict control over execution ordering for a sinlgle test case and second we are using approximate comparison of resulting durations <code>require.LessOrEqual(t, int64(rdur/2), int64(dur))</code> to reduce test brittleness.</p>
<p>I acknowledge that this code is far from masterpiece. Moreover, it even fails occasionally (from my experience false positive rate is less than couple percents) which could be resolved by further adjusting comparison durations threshold and tuning individual test cases. But overal, this code works great and it helped me to reduce test helper boilerplates to the bare minimum.</p>
<p>Instead of any conclusion, I want to provide some numbers for <a href="https://github.com/1pkg/gohalt">gohalt</a> tests. The ratio of test setup helper code to real test case scenarios is approximately <code>1:7</code>. The ratio of test code to library code itself is an approximately <code>1:1</code> while vast majority of all code is fully covered. I highly doubt that the same amount of tests with the same coverage could be possible if the rule of simple tests was followed. So, as always, don&rsquo;t follow any Software Engineering dogma blindly, think what suits your situation best and stay tuned for more reading!</p>


  </div>
  <footer class="post-footer">
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2022 <a href="https://1pkg.github.io">1pkg dev blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
