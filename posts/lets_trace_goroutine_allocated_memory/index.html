<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Let&#39;s trace goroutine allocated memory | Kostinatyn Masliuk | 1pkg dev blog</title>
<meta name="keywords" content="" />
<meta name="description" content="Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it&rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it&rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions.">
<meta name="author" content="Kostiantyn Masliuk">
<link rel="canonical" href="https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ef101b82f5d0f216577b2b1b33ac59cbf6ec31115df5bcc763ade95cf25496d5.css" integrity="sha256-7xAbgvXQ8hZXeysbM6xZy/bsMRFd9bzHY63pXPJUltU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://1pkg.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://1pkg.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://1pkg.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://1pkg.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://1pkg.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />
<meta property="og:title" content="Let&#39;s trace goroutine allocated memory" />
<meta property="og:description" content="Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it&rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it&rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-12-08T00:00:00&#43;00:00" /><meta property="og:site_name" content="Kostinatyn Masliuk | 1pkg dev blog" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Let&#39;s trace goroutine allocated memory"/>
<meta name="twitter:description" content="Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it&rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it&rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://1pkg.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Let's trace goroutine allocated memory",
      "item": "https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Let's trace goroutine allocated memory",
  "name": "Let\u0027s trace goroutine allocated memory",
  "description": "Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it\u0026rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it\u0026rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions.",
  "keywords": [
    
  ],
  "articleBody": "Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it’s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it’s not that simple in languages like Go that are hiding memory management details inside runtime abstractions. Nevertheless, there is a chunk of use cases where you absolutely have to have a notion of allocated memory for your application. Then if you know your memory allocations, you can define memory quotas for the whole process or even memory budgets for specific operations (which could be extremely useful in application like databases, complex parsers, etc.) There are also goto list of popular answers for memory tracing in go:\n  you can use MemStats output to control memory consumption of the whole process, but it doesn’t provide enough granularity and could be too fuzzy to use.\n  you can use OS (including any imaginable virtualization solutions) tools directly to achieve same effect as above; though problems are the same: poor granularity and fuzziness.\n  to gain full control you can write somewhat a custom memory allocator and garbage collector by yourself; for e.g. TiDB has chunk and tracker that are used to allocate and track meaningful chunks of resources in TiDB per query, another example is Couchbase go-slab allocator, etc.; this is a great approach but still it has downsides - it’s not go native which means builtin structures are not traced at all thus they should be avoided in critical places; it’s tailored to specific use case or even code base and demands a lot of efforts to port and adopt it properly into other code bases.\n  you can calculate each allocated object size by your self; good example is dgraph that opened an issue in which they have problems to accurately meassure objects size using creachadair/misctools/sizeof; in conclusion it’s good method for quick estimation in my opinion although it lacks precision and requires lots of boilerplate code to measure size of each object.\n  All methods described above are doing great job for certain situations, but you might ask is there any universal single solution that can be easily plugged to existing go code base be precise enough and provide good granularity? Ideally we want to have simple yet convenient interface for memory allocation tracing enabled by default for any generic purpose go code.\nIntroduction of gotcha library Meet gotcha package that seamlessly patches go runtime to provide a convenient way to track amount of heap allocated bytes, objects, calls per goroutine.\npackage main import ( \"context\" \"fmt\" \"github.com/1pkg/gotcha\" ) func main() { var v []int gotcha.Trace(context.Background(), func(ctx gotcha.Context) { v = make([]int, 100) b, o, c := ctx.Used() // bytes objects calls \tfmt.Println(\"initial allocation\", b, o, c) // will print \"initial allocation 824 101 2\" \tgotcha.Trace(ctx, func(ctx gotcha.Context) { v = make([]int, 5000) b, o, c := ctx.Used() // bytes objects calls \tfmt.Println(\"derived allocation\", b, o, c) // will print \"derived allocation 40024 5001 2\" \t}) select { case ctx.Done(): b, o, c := ctx.Used() // bytes objects calls \tfmt.Println(\"total allocations\", b, o, c) // will print \"total allocations 41840 5116 15\" \tdefault: panic(\"unreachable\") } }, gotcha.ContextWithLimitBytes(gotcha.KiB)) // set context allocation limit to one kilobit \t// note that prints above might be slightly different on your machine \tfmt.Println(len(v)) // 5000 } Gotcha exposes single function Trace that tracks memory allocations for provided Tracer function. All traced allocation results then are added to the single context parameter of this Tracer function. This way context is seamlessly staying updated and tracking all memory allocations happened in current function scope.\nGotcha context fully implements context.Context interface and could be used to cancel execution if provided memory limits were exceeded. Gotcha supports nested tracing by providing gotcha context as parent context for derived Tracer function; then gotcha tracing context methods will also target parent context as well as derived context.\nIt’s important to say that gotcha is not trying to measure momentary memory usage which involves GC tracing into the act, keeping track on GC is rather a big task on it’s own and out of scope for gotcha. Instead gotcha traces all memory allocated in monotonic increasing fashion where is only allocations are taken into consideration and all deallocations are discarded.\nHow does gotcha even work? In order to understand what we need to do, we need understand how go runtime allocates memory in first place. After some reading inside go runtime we can find next definition file.\n// Allocate an object of size bytes. // Small objects are allocated from the per-P cache's free lists. // Large objects ( 32 kB) are allocated straight from the heap. func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer This is the single most important entrypoint for managed heap memory allocations in go. All possible allocations for objects, arrays, strings, slice, map, etc. will use this function to allocate memory required for them. As always there are numbers of exceptions to the mallocgc: direct malloc calls, etc. but for simplicity we won’t consider them meaningful for us.\nSo in theory we just need to hook to mallocgc function with our custom code that collects number of allocated objects, bytes, calls - profit. What seems like a simple idea rather requires not trivial implementation in go, apart from security concerns (messing with go allocator), there are dozens of implementation problems too: mallocgc is internal go runtime function not exposed to the world, even if mallocgc would have been exported - mallocgc is a function that simply allocates an object of n bytes and doesn’t provide neither any way to trace this nor hook callback nor sort of allocation events. Then even if we have patched tracing mallocgc function we need to have an ability to track allocation per goroutine which is tricky because go doesn’t provide any simple way to uniquely identify goroutines whatsoever.\nUnexported function - go:linkname to rescue Need of exporting unexported function in go is not new. There is a great article on searching ways how to do it link. Briefly, it’s possible to export any internal function using //go:linkname compiler directive. From the godoc:\n//go:linkname localname [importpath.name] This special directive does not apply to the Go code that follows it. Instead, the //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. If the “importpath.name” argument is omitted, the directive uses the symbol's default object file symbol name and only has the effect of making the symbol accessible to other packages. Because this directive can subvert the type system and package modularity, it is only enabled in files that have imported \"unsafe\". Okay great, so using next function definition with go:linkname compiler directive in our local package will do the trick - links internal mallocgc function body from runtime package to our local function definition.\n// tp from `runtime._type` type tp struct { size uintptr } //go:linkname mallocgc runtime.mallocgc func mallocgc(size uintptr, tp *tp, needzero bool) unsafe.Pointer Note how we defined our custom tp type replacement for runtime._type. We don’t need to have a full copy of fields from runtime._type only fields that we will use and memory paddings between. It comes from the fact that mallocgc accepts a pointer to the type which makes both *tp and *runtime._type to be intercompatible with each other.\nLogically go:linkname could be used not only for accessing existing function implementation but also for linking the implementation to the function name. This is probably the main reason why go:linkname exists in first place, by using it for example you can link the go function definition facade to some native code implementation. Which means that if we could hope for some smart linker behavior (like last go:linkname should win the linking) we then can redefine mallocgc function implementation directly, or even better link original mallocgc body to temporary function to keep allocation code untouched and then redefine mallocgc to hook allocations tracing.\n// tp from `runtime._type` type tp struct { size uintptr } //go:linkname mallocgcOrigin runtime.mallocgc func mallocgcOrigin(size uintptr, tp *tp, needzero bool) unsafe.Pointer //go:linkname mallocgc runtime.mallocgc func mallocgc(size uintptr, tp *tp, needzero bool) unsafe.Pointer { // trace allocations here  // allocBytes += size  // allocObjects += size / tp.size  // allocCount += 1  return mallocgcOrigin(size) } Unfortunately go linker doesn’t have any sort of heuristics and simply doesn’t allow to link multiple bodies to single function name, which results in error similar to duplicate symbol runtime.mallocgc. So we need to find a different way how to hook memory allocations tracing to mallocgc.\nAllocation hooking - code patching to rescue As it was said before go runtime doesn’t expose any simple way how to hook to mallocgc. The only way to hook memory allocations tracing to mallocgc is to override mallocgc in next fashion.\n//go:linkname mallocgc runtime.mallocgc func mallocgc(size uintptr, tp *tp, needzero bool) unsafe.Pointer { // trace allocations here  // allocBytes += size  // allocObjects += size / tp.size  // allocCount += 1  return mallocgcOrigin(size) } The patch above is trivial with dynamic interpreter languages like python or javascript. Where function represented in some form of objects with additional meta data attached to them and their body executed on the call. In such environments it’s fairly easy to substitute function implementations. On the other hand go is compiled language which means all function code is compiled to machine code and then machine code is executed. This definitely restricts possibilities of patching code on the fly although it doesn’t kill possibilities entirely.\nAgain this is not the first time when go code patching is required, so bouk/monkey was developed long ago article. Basically, this library does really simple thing; it replaces the start of original function body with machine code jump instruction to target patch body instead, which is exactly what we need.\nCode patching in depth naive approach As a side affect of bouk/monkey usage body of original function become completely lost because of unconditional jump instruction replacement. This is problematic for our tracing because now we can trace allocations but original allocation mallocgc code itself is gone. Okay not a huge problem we can copy paste original go mallocgc implementation from runtime package to our local mallocgcOrigin and live with this, right? Not really, there are multiple problems with that:\n mallocgc depends on numbers of different internal runtime functions which needs to be referenced by go:linkname or copied as well. any future internal mallocgc code update will make our local mallocgc patch inaccurate. mallocgc inconsistency with previous go runtime versions, problem is the same as the problem above but integrated over the time; what should be done for previous runtime versions, should accurate mallocgc code be copied for each possible go version? meh …  Code patching in depth semi naive approach Okay, if we can’t patch mallocgc function directly let’s search for all its usage inside go runtime code. Not bad we need to patch 20+ functions instead of one now 😿. But if you look closely a lot of those functions are either direct call to mallocgc which is trivial to patch or functions that probably are not even 100% important to patch like interface.conv family that is used for allocations for code like vt, ok := var.(type). Sure there are some bigger functions over there (makeslice, growslice, etc.) too that could be either fully replaced see, ignored, or patched with bouk/monkey patch guard.\nbouk/monkey patch guard is basically the way how to call original function from the patch, the idea is pretty straightforward instead of just replacing original function code with unconditional jump bouk/monkey - save original bytes before the replacing. Then by calling unpatch on the guard function body of patched function is restored back to original for current function call and then patched back with deferred restore call on the guard.\nvar gmakeSlice *monkey.PatchGuard gmakeSlice = monkey.Patch(makeslice, func(tp *tp, len, cap int) unsafe.Pointer { gmakeSlice.Unpatch() defer gmakeSlice.Restore() // trace allocations here  // allocBytes += tp.size * len  // allocObjects += tp.size  // allocCount += 1  return makeslice(tp, len, cap) }) This approach is great why not use it for mallocgc directly? Well in fact it doesn’t work; underneath bouk/monkey patch guard has allocations that cause infinite loop on unpatch call. But here comes more: it’s unsafe to use the guard because it’s not thread safe, while function is unpatched back to original mallocgc code another allocation call could happen.\nCode patching in depth fighting to the end The problem is obvious we need to patch mallocgc permanently while still have access to original mallocgc. Modifying bouk/monkey patch guard we can try remove all excess allocations and keep just bytes flipping (coping) forward and backward in both unpatch and restore functions respectively. This still doesn’t solve the problem with thread safety though, meaning either synchronization of each mallocgc allocation (which is ridiculous) or drop patch solution totally and search for different ideas.\nSimplest of these ideas could be to copy original function body to third independent function before patching. The problem with this approach to find original body boundaries which in machine code means finding last ret instruction. To find it we need to implement sort of custom assembly parser which will be able to parse hex machine instructions, follow all the jumps, etc.; also keep in mind that ideally this custom parser should support the same list of supported architectures as go. Sounds too complicated for the memory allocation tracing task …\nmonkey.Patch(makeslice, func(tp *tp, len, cap int) unsafe.Pointer { // trace allocations here  // allocBytes += tp.size * len  // allocObjects += tp.size  // allocCount += 1  return mallocgcHolder(tp, len, cap) }, mallocgcHolder) Also this approach has another interesting requirement, if as stated before we are going to use the third independent function to hold original function body, in the simplest preallocated holder implementation, should at least have the same bytes size of body as original function body has. The tricky part is: in order to get size of original body, we need to disassembly original binary, count the original bytes, and create weird holder function that reasonably covers amount of bytes needed to fit original body this holder body never will be used directly.\nfunc mallocgcHolder(size uintptr, tp *tp, needzero bool) unsafe.Pointer { fmt.Println(\"unreachable\") fmt.Println(\"unreachable\") fmt.Println(\"unreachable\") ... ... ... fmt.Println(\"unreachable\") fmt.Println(\"unreachable\") fmt.Println(\"unreachable\") return nil } Okay function body copying is not what we searched for, let’s try to improve existing jump implementation instead. Instead of jump replacement at the start of original body we could replace jump at the end of function body. Effectively we need to replace all existing ret instruction in original function body. With this implementation first original mallocgc function will be executed and then right after our patched decorator will be executed as well.\nThe problem with this idea is exactly the same as with idea before: the implementation requires to find all ret instructions which means parsing assembly. On top of this generally it’s unsafe to replace ret instruction with our custom jump instruction because instructions have different sizes. This most likely will lead to replacing other unwanted code parts, not only desirable ret in mallocgc.\nOkay so we 100% know now that we can’t really deviate from jump at the start of the function. We also know that we need to execute both function bodies original and patch decorator, so just jump is not really suitable. Luckily we could try to use call instruction that does exactly what we need: jump to patch decorator, execute patch decorator, jump back to original place where it left it.\nSadly this also expectedly fails because original function body is destroyed by call replacement. By replacing instructions at the function top we are removing function stack setup logic _runtime.morestack_noctxt link, so in reallity we can’t directly patch function start. What we can try instead - find and patch a place near the top of mallocgc that has relatively “unuseful” code.\nThe first check that verifies GC phase invariant and throws a panic, seems not 100% important to me. Panic basically means this piece of code should be unreachable 99.99(9)% of the normal execution time and probably could be sacrificed for our higher goal 😈. Let’s take a look at mallocgc assembly one more time and calculate what bytes offset should be used to patch this exact check.\nLooks like for amd64 architecture offset is 24 bytes. Let’s modify existing bouk/monkey to use this offset and try again.\nAs you can expect such patching doesn’t work again. Currently, the problem is - we are patching only a part of original sacrificed if block which leaves random bytes artifacts right after patched code that can’t be executed and leading to crash. Good for us it’s easy enough to fix - what we need to pad our patch block with nop instructions to match original replaced block size.\nDoes it work this time? Yes, No, Not really???\nBasically with call offset pad method we’ve almost achieved desired behavior, indeed decorator patch is called first and then original mallocgc body is executed (without first if block). The only slight issue our decorator doesn’t receive proper (size uintptr, tp *tp, needzero bool) arguments. In fact it receives some sort of messed memory instead which redirects us to reading go function calling convention.\nThere are not a lot to say there: currently go uses stack based calling convention. There are some nice articles that gives you basic understanding of go calling convention basics #1 #2. Back to our issue in order to execute the call we need to use the calling convention, which means push the arguments to stack and update virtual stack pointer SP (the implementation for amd64 is listed bellow).\n# before call sub rsp,0x28 # allocate needed stack for call mov rax,QWORD PTR [rsp+0x30] # load argument 1 from the stack mov QWORD PTR [rsp],rax # push argument 1 to the stack for call mov rax,QWORD PTR [rsp+0x38] # load argument 2 from the stack mov QWORD PTR [rsp],rax # push argument 2 to the stack for call # execute call movabs rdx, PTR # load patch decorator address to call call QWORD PTR [rdx] # call patch decorator # after call add rsp,0x28 # reset stack after call sub rsp,0x98 # reset stack to initial `mallogcgc` state This implementation translates to 46 bytes for amd64, which unfortunately means we need more original mallocgc code to be sacrificed. Back to original mallocgc implementation we will need second if guard as well as first to cover patch size.\nThe second check seems a bit more important than first one, although probably it just serves “fast allocation code path” and we can replace it too (anyhow we don’t have any choice). All together first check + second check give us 53 bytes which is fine for us as we need only 46 bytes.\nPutting it all together and our patching started to work 🎉. I decided to put patching code to separate library 1pkg/gomonkey, there are two reasons: patching described above needed for gotcha is really drifted away from original library and bouk/monkey is no longer supported by the author anyway.\n// PermanentDecorate decorates function target call // with replacement function call by replacing // original function starting at offset with padding assembly bytes func PermanentDecorate(t, r interface{}, offset, padding int, before, after []byte) Note: despite that implementation above works, it’s super unsafe. It uses code assumption about mallocgc, depends on calling convention that could be soon changed #1 #2, uses platform specific machine code direcly, etc. This implementation isn’t expected to work on anything apart from amd64 with latest go runtime. Nevertheless, you can try to use or even improve this patching implementation at your own peril!\nFinally, there are more possible ideas how to implement this patching even simpler potentially. As we did with full body copping, we can use third independent function holder to store not full original body copy this time but rather the only custom jump to the place right after original patch instruction, effectively doing double jump (this way we can try to avoid stack manipulations at all).\nOr we could try to replace not important parts of original function body with full patch decorator body (if we manage to make it tiny enough) instead of jump (same restrictions as with full body copy). There are also definitely many other possible methods and solutions exist but not described in this article. Finally after playing long enough with different options and tricks, I decided to stick with working yet not ideal call offset pad with stack. I don’t see any more benefits for gotcha to move forward with better patching methods for now because indeed patching is important part of the library but not its exclusive component. Also worth to mention that my poor assembly knowledge didn’t help me on this way neither so if anyone has any good idea how to improve the patching, please let me know.\nGoroutine identifier - go runtime to rescue As we need to trace current memory consumption on goroutine basis. We need to have a mechanism to get a sort of unique identifier for any traced goroutine. Then using that we can instantiate global map where goroutine identifiers stored and act as keys and tracing object as values. Then on each mallocgc call in our hook function we need to look up the global map for current tracing object, if no object is found then create new tracing object and use it, then update the tracing object with a delta of newly allocated bytes, objects, calls.\nAgain as with other problems, need for goroutine local storage existed long before (especially in time before context conquered the go world). There are several opensource implementations to achieve the effect - I decided to go with modern-go/gls because of nice and clean package interface. This package uses a runtime trick to obtain a pointer to the current goroutine structure runtime.g then adds specific bytes offset to this pointer to access goid identifier field. By using this package, we now can trace each goroutine memory consumption separately which is what we wanted.\nHowever, there is an issue with using modern-go/gls directly - it allocates memory (map operations inside library). Logically enough allocations inside mallocgc will call another mallocgc which in turn will call another mallocgc which in turn … infinite loop. What we need instead to have preallocated map on startup before patching and using this bound storage instead; by tweaking modern-go/gls we end up with tiny storage package 1pkg/golocal that does single map allocation once, and works on bound storage further on (storage size could be tweaked by env variable). Also it’s utilizing single rw mutex for locking which could cause some blocked allocations!!! Not really likely though as blocking operations set and del called extremely rare compared to nonblocking get that called on each given allocation.\nFinal conclusion In final conclusion we can highlight that needs of accurate memory allocation tracing exists. It doesn’t matter how good your languages tries to hide and abstract memory management, sometimes you just need to know memory consumptions and have some sort of handles to operate if memory consumption hits certain watermarks. Some of newer languages don’t provide you any direct introspective tools or they are too limited or not granular enough, go is an example of such language. So decision was made to try to provide everybody with a comfy library that helps with granular memory tracing for go.\nWhat makes go so special in my opinion is one of its greatest merit “features and implementations conservatism” but also it strikes back sometimes - there is no straightforward way how to override core golang rules (which is overall a good thing). But as always in real life, there is at least a single exception for any given rule. Going wild with number of those exceptions go linkname code patching goroutine identifier we are able to bend the rules but not break them.\nIn the end final gotcha implementation has reached its goals. It traces most of the memory allocations with certain precision and somewhat idiomatic and friendly interface. On the other hand restrictions that gotcha implies make its usage simply not worth it. So I highly discourage anyone to use gotcha in any production code or maybe even any code at all as it’s extremely unsafe and not reliable and won’t be supported in foreseeable future. Nevertheless, one could probably imagine reasonable use cases for this concept library in go benchmarks or test. Finally it’s worth to say that primary intention to develop gotcha was learning and that gotcha doesn’t have comprehensive tests coverage and support and not ready for any serious use case anyway. However, I hope you enjoyed the reading and understood the main idea of this article: “despite you can adjust any generic piece to your specific needs if you try hard (especially with things that are designed in radically opposite way) it hardly worthy it in most of the cases; use specific solutions instead if you can”.\n",
  "wordCount" : "4232",
  "inLanguage": "en",
  "datePublished": "2020-12-08T00:00:00Z",
  "dateModified": "2020-12-08T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Kostiantyn Masliuk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kostinatyn Masliuk | 1pkg dev blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://1pkg.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://1pkg.github.io" accesskey="h" title="~ (Alt + H)">~</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Let&#39;s trace goroutine allocated memory
    </h1>
    <div class="post-meta">December 8, 2020&nbsp;·&nbsp;Kostiantyn Masliuk
</div>
  </header> 
  <div class="post-content"><h2 id="memory-tracing-retrospective">Memory tracing retrospective<a hidden class="anchor" aria-hidden="true" href="#memory-tracing-retrospective">#</a></h2>
<p>On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it&rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it&rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions. Nevertheless, there is a chunk of use cases where you absolutely have to have a notion of allocated memory for your application. Then if you know your memory allocations, you can define memory quotas for the whole process or even memory budgets for specific operations (which could be extremely useful in application like databases, complex parsers, etc.) There are also goto list of popular answers for memory tracing in go:</p>
<ul>
<li>
<p>you can use <a href="https://golang.org/pkg/runtime/#ReadMemStats">MemStats</a> output to control memory consumption of the whole process, but it doesn&rsquo;t provide enough granularity and could be too fuzzy to use.</p>
</li>
<li>
<p>you can use OS (including any imaginable virtualization solutions) tools directly to achieve same effect as above; though problems are the same: poor granularity and fuzziness.</p>
</li>
<li>
<p>to gain full control you can write somewhat a custom memory allocator and garbage collector by yourself; for e.g. TiDB has <a href="https://github.com/pingcap/tidb/tree/master/util/chunk">chunk</a> and <a href="https://github.com/pingcap/tidb/blob/master/util/memory/tracker.go">tracker</a> that are used to allocate and track meaningful chunks of resources in TiDB per query, another example is Couchbase <a href="https://github.com/couchbase/go-slab">go-slab</a> allocator, etc.; this is a great approach but still it has downsides - it&rsquo;s not go native which means builtin structures are not traced at all thus they should be avoided in critical places; it&rsquo;s tailored to specific use case or even code base and demands a lot of efforts to port and adopt it properly into other code bases.</p>
</li>
<li>
<p>you can calculate each allocated object size by your self; good example is dgraph that opened an <a href="https://github.com/golang/go/issues/34561">issue</a> in which they have problems to accurately meassure objects size using <a href="https://github.com/creachadair/misctools/blob/default/sizeof/size.go#L31">creachadair/misctools/sizeof</a>; in conclusion it&rsquo;s good method for quick estimation in my opinion although it lacks precision and requires lots of boilerplate code to measure size of each object.</p>
</li>
</ul>
<p>All methods described above are doing great job for certain situations, but you might ask is there any universal single solution that can be easily plugged to existing go code base be precise enough and provide good granularity? Ideally we want to have simple yet convenient interface for memory allocation tracing enabled by default for any generic purpose go code.</p>
<h2 id="introduction-of-gotcha-library">Introduction of gotcha library<a hidden class="anchor" aria-hidden="true" href="#introduction-of-gotcha-library">#</a></h2>
<p>Meet <a href="https://github.com/1pkg/gotcha">gotcha</a> package that seamlessly patches go runtime to provide a convenient way to track amount of heap allocated bytes, objects, calls per goroutine.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;context&#34;</span>
	<span style="color:#e6db74">&#34;fmt&#34;</span>

	<span style="color:#e6db74">&#34;github.com/1pkg/gotcha&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> []<span style="color:#66d9ef">int</span>
	<span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">Trace</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">Context</span>) {
		<span style="color:#a6e22e">v</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">100</span>)
		<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Used</span>() <span style="color:#75715e">// bytes objects calls
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;initial allocation&#34;</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span>) <span style="color:#75715e">// will print &#34;initial allocation 824 101 2&#34;
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">Trace</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">Context</span>) {
			<span style="color:#a6e22e">v</span> = make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5000</span>)
			<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Used</span>() <span style="color:#75715e">// bytes objects calls
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;derived allocation&#34;</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span>) <span style="color:#75715e">// will print &#34;derived allocation 40024 5001 2&#34;
</span><span style="color:#75715e"></span>		})
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
			<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Used</span>() <span style="color:#75715e">// bytes objects calls
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;total allocations&#34;</span>, <span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">o</span>, <span style="color:#a6e22e">c</span>) <span style="color:#75715e">// will print &#34;total allocations 41840 5116 15&#34;
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">default</span>:
			panic(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
		}
	}, <span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">ContextWithLimitBytes</span>(<span style="color:#a6e22e">gotcha</span>.<span style="color:#a6e22e">KiB</span>)) <span style="color:#75715e">// set context allocation limit to one kilobit
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// note that prints above might be slightly different on your machine
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(len(<span style="color:#a6e22e">v</span>)) <span style="color:#75715e">// 5000
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Gotcha exposes single function <code>Trace</code> that tracks memory allocations for provided <code>Tracer</code> function. All traced allocation results then are added to the single context parameter of this <code>Tracer</code> function. This way context is seamlessly staying updated and tracking all memory allocations happened in current function scope.</p>
<p>Gotcha context fully implements <code>context.Context</code> interface and could be used to cancel execution if provided memory limits were exceeded. Gotcha supports nested tracing by providing gotcha context as parent context for derived <code>Tracer</code> function; then gotcha tracing context methods will also target parent context as well as derived context.</p>
<p>It&rsquo;s important to say that gotcha is not trying to measure momentary memory usage which involves GC tracing into the act, keeping track on GC is rather a big task on it&rsquo;s own and out of scope for gotcha. Instead gotcha traces all memory allocated in monotonic increasing fashion where is only allocations are taken into consideration and all deallocations are discarded.</p>
<h2 id="how-does-gotcha-even-work">How does gotcha even work?<a hidden class="anchor" aria-hidden="true" href="#how-does-gotcha-even-work">#</a></h2>
<p>In order to understand what we need to do, we need understand how go runtime allocates memory in first place. After some reading inside go runtime we can find next definition <a href="https://golang.org/src/runtime/malloc.go#L903">file</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Allocate an object of size bytes.
</span><span style="color:#75715e">// Small objects are allocated from the per-P cache&#39;s free lists.
</span><span style="color:#75715e">// Large objects (&gt; 32 kB) are allocated straight from the heap.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">typ</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</code></pre></div><p>This is the single most important entrypoint for managed heap memory allocations in go. All possible allocations for objects, arrays, strings, slice, map, etc. will use this function to allocate memory required for them. As always there are numbers of exceptions to the <code>mallocgc</code>: direct malloc calls, etc. but for simplicity we won&rsquo;t consider them meaningful for us.</p>
<p>So in theory we just need to hook to <code>mallocgc</code> function with our custom code that collects number of allocated objects, bytes, calls - profit. What seems like a simple idea rather requires not trivial implementation in go, apart from security concerns (messing with go allocator), there are dozens of implementation problems too: <code>mallocgc</code> is internal go runtime function not exposed to the world, even if <code>mallocgc</code> would have been exported - <code>mallocgc</code> is a function that simply allocates an object of n bytes and doesn&rsquo;t provide neither any way to trace this nor hook callback nor sort of allocation events. Then even if we have patched tracing <code>mallocgc</code> function we need to have an ability to track allocation per goroutine which is tricky because go doesn&rsquo;t provide any simple way to uniquely identify goroutines whatsoever.</p>
<h3 id="unexported-function---golinkname-to-rescue">Unexported function - go:linkname to rescue<a hidden class="anchor" aria-hidden="true" href="#unexported-function---golinkname-to-rescue">#</a></h3>
<p>Need of exporting unexported function in go is not new. There is a great article on searching ways how to do it <a href="http://www.alangpierce.com/blog/2016/03/17/adventures-in-go-accessing-unexported-functions/">link</a>. Briefly, it&rsquo;s possible to export any internal function using <code>//go:linkname</code> <a href="https://golang.org/cmd/compile/#hdr-Compiler_Directives">compiler directive</a>. From the godoc:</p>
<pre><code>//go:linkname localname [importpath.name]

This special directive does not apply to the Go code that follows it.
Instead, the //go:linkname directive instructs the compiler to use
“importpath.name” as the object file symbol name for the variable or function
declared as “localname” in the source code. If the “importpath.name” argument is omitted,
the directive uses the symbol's default object file symbol name and only has
the effect of making the symbol accessible to other packages.
Because this directive can subvert the type system and package modularity,
it is only enabled in files that have imported &quot;unsafe&quot;.
</code></pre><p>Okay great, so using next function definition with <code>go:linkname</code> compiler directive in our local package will do the trick - links internal <code>mallocgc</code> function body from <code>runtime</code> package to our local function definition.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// tp from `runtime._type`
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tp</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>
}

<span style="color:#75715e">//go:linkname mallocgc runtime.mallocgc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</code></pre></div><p>Note how we defined our custom <code>tp</code> type replacement for <code>runtime._type</code>. We don&rsquo;t need to have a full copy of fields from <code>runtime._type</code> only fields that we will use and memory paddings between. It comes from the fact that <code>mallocgc</code> accepts a pointer to the type which makes both <code>*tp</code> and <code>*runtime._type</code> to be intercompatible with each other.</p>
<p>Logically <code>go:linkname</code> could be used not only for accessing existing function implementation but also for linking the implementation to the function name. This is probably the main reason why <code>go:linkname</code> exists in first place, by using it for example you can link the go function definition facade to some native code implementation. Which means that if we could hope for some smart linker behavior (like last <code>go:linkname</code> should win the linking) we then can redefine <code>mallocgc</code> function implementation directly, or even better link original <code>mallocgc</code> body to temporary function to keep allocation code untouched and then redefine <code>mallocgc</code> to hook allocations tracing.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// tp from `runtime._type`
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tp</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>
}

<span style="color:#75715e">//go:linkname mallocgcOrigin runtime.mallocgc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgcOrigin</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>

<span style="color:#75715e">//go:linkname mallocgc runtime.mallocgc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
  <span style="color:#75715e">// trace allocations here
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocBytes += size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocObjects += size / tp.size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocCount += 1
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mallocgcOrigin</span>(<span style="color:#a6e22e">size</span>)
}
</code></pre></div><p>Unfortunately go linker doesn&rsquo;t have any sort of heuristics and simply doesn&rsquo;t allow to link multiple bodies to single function name, which results in error similar to <code>duplicate symbol runtime.mallocgc</code>. So we need to find a different way how to hook memory allocations tracing to <code>mallocgc</code>.</p>
<h3 id="allocation-hooking---code-patching-to-rescue">Allocation hooking - code patching to rescue<a hidden class="anchor" aria-hidden="true" href="#allocation-hooking---code-patching-to-rescue">#</a></h3>
<p>As it was said before go runtime doesn&rsquo;t expose any simple way how to hook to <code>mallocgc</code>. The only way to hook memory allocations tracing to <code>mallocgc</code> is to override <code>mallocgc</code> in next fashion.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//go:linkname mallocgc runtime.mallocgc
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
  <span style="color:#75715e">// trace allocations here
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocBytes += size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocObjects += size / tp.size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocCount += 1
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mallocgcOrigin</span>(<span style="color:#a6e22e">size</span>)
}
</code></pre></div><p>The patch above is trivial with dynamic interpreter languages like python or javascript. Where function represented in some form of objects with additional meta data attached to them and their body executed on the call. In such environments it&rsquo;s fairly easy to substitute function implementations. On the other hand go is compiled language which means all function code is compiled to machine code and then machine code is executed. This definitely restricts possibilities of patching code on the fly although it doesn&rsquo;t kill possibilities entirely.</p>
<p>Again this is not the first time when go code patching is required, so <a href="https://github.com/bouk/monkey">bouk/monkey</a> was developed long ago <a href="https://bou.ke/blog/monkey-patching-in-go/">article</a>. Basically, this library does really simple thing; it replaces the start of original function body with machine code <code>jump</code> instruction to target patch body instead, which is exactly what we need.</p>
<p><img loading="lazy" src="/monkey_patching_base.png" alt="monkey patching base"  />
</p>
<h4 id="code-patching-in-depth-naive-approach">Code patching in depth naive approach<a hidden class="anchor" aria-hidden="true" href="#code-patching-in-depth-naive-approach">#</a></h4>
<p>As a side affect of <code>bouk/monkey</code> usage body of original function become completely lost because of unconditional <code>jump</code> instruction replacement. This is problematic for our tracing because now we can trace allocations but original allocation <code>mallocgc</code> code itself is gone. Okay not a huge problem we can copy paste original go <code>mallocgc</code> implementation from <code>runtime</code> package to our local <code>mallocgcOrigin</code> and live with this, right? Not really, there are multiple problems with that:</p>
<ul>
<li><code>mallocgc</code> depends on numbers of different internal runtime functions which needs to be referenced by <code>go:linkname</code> or copied as well.</li>
<li>any future internal <code>mallocgc</code> code update will make our local <code>mallocgc</code> patch inaccurate.</li>
<li><code>mallocgc</code> inconsistency with previous go runtime versions, problem is the same as the problem above but integrated over the time; what should be done for previous runtime versions, should accurate <code>mallocgc</code> code be copied for each possible go version? meh &hellip;</li>
</ul>
<h4 id="code-patching-in-depth-semi-naive-approach">Code patching in depth semi naive approach<a hidden class="anchor" aria-hidden="true" href="#code-patching-in-depth-semi-naive-approach">#</a></h4>
<p>Okay, if we can&rsquo;t patch <code>mallocgc</code> function directly let&rsquo;s search for all its usage inside go runtime code.
<img loading="lazy" src="/mallocgc_runtime_usage.png" alt="mallocgc runtime usage"  />

Not bad we need to patch 20+ functions instead of one now 😿. But if you look closely a lot of those functions are either direct call to <code>mallocgc</code> which is trivial to patch or functions that probably are not even 100% important to patch like <code>interface.conv</code> family that is used for allocations for code like <code>vt, ok := var.(type)</code>. Sure there are some bigger functions over there (<code>makeslice</code>, <code>growslice</code>, etc.) too that could be either fully replaced <a href="#code-patching-in-depth-naive-approach">see</a>, ignored, or patched with <code>bouk/monkey</code> patch guard.</p>
<p><code>bouk/monkey</code> patch guard is basically the way how to call original function from the patch, the idea is pretty straightforward instead of just replacing original function code with unconditional jump <code>bouk/monkey</code> - save original bytes before the replacing. Then by calling unpatch on the guard function body of patched function is restored back to original for current function call and then patched back with deferred restore call on the guard.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gmakeSlice</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">monkey</span>.<span style="color:#a6e22e">PatchGuard</span>
<span style="color:#a6e22e">gmakeSlice</span> = <span style="color:#a6e22e">monkey</span>.<span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">makeslice</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
  <span style="color:#a6e22e">gmakeSlice</span>.<span style="color:#a6e22e">Unpatch</span>()
  <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">gmakeSlice</span>.<span style="color:#a6e22e">Restore</span>()
  <span style="color:#75715e">// trace allocations here
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocBytes += tp.size * len
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocObjects += tp.size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocCount += 1
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">makeslice</span>(<span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span>)
})
</code></pre></div><p>This approach is great why not use it for <code>mallocgc</code> directly? Well in fact it doesn&rsquo;t work; underneath <code>bouk/monkey</code> patch guard has allocations that cause infinite loop on unpatch call. But here comes more: it&rsquo;s unsafe to use the guard because it&rsquo;s not thread safe, while function is unpatched back to original <code>mallocgc</code> code another allocation call could happen.</p>
<h4 id="code-patching-in-depth-fighting-to-the-end">Code patching in depth fighting to the end<a hidden class="anchor" aria-hidden="true" href="#code-patching-in-depth-fighting-to-the-end">#</a></h4>
<p>The problem is obvious we need to patch <code>mallocgc</code> permanently while still have access to original <code>mallocgc</code>. Modifying <code>bouk/monkey</code> patch guard we can try remove all excess allocations and keep just bytes flipping (coping) forward and backward in both unpatch and restore functions respectively. This still doesn&rsquo;t solve the problem with thread safety though, meaning either synchronization of each <code>mallocgc</code> allocation (which is ridiculous) or drop patch solution totally and search for different ideas.</p>
<p>Simplest of these ideas could be to copy original function body to third independent function before patching. The problem with this approach to find original body boundaries which in machine code means finding last <code>ret</code> instruction. To find it we need to implement sort of custom assembly parser which will be able to parse hex machine instructions, follow all the jumps, etc.; also keep in mind that ideally this custom parser should support the same list of supported architectures as go. Sounds too complicated for the memory allocation tracing task &hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">monkey</span>.<span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">makeslice</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
  <span style="color:#75715e">// trace allocations here
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocBytes += tp.size * len
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocObjects += tp.size
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// allocCount += 1
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mallocgcHolder</span>(<span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span>)
}, <span style="color:#a6e22e">mallocgcHolder</span>)
</code></pre></div><p><img loading="lazy" src="/monkey_patching_copy.png" alt="monkey patching copy"  />

<img loading="lazy" src="/monkey_patching_base.png" alt="monkey patching base"  />
</p>
<p>Also this approach has another interesting requirement, if as stated before we are going to use the third independent function to hold original function body, in the simplest preallocated holder implementation, should at least have the same bytes size of body as original function body has. The tricky part is: in order to get size of original body, we need to disassembly original binary, count the original bytes, and create weird holder function that reasonably covers amount of bytes needed to fit original body this holder body never will be used directly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">mallocgcHolder</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">uintptr</span>, <span style="color:#a6e22e">tp</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tp</span>, <span style="color:#a6e22e">needzero</span> <span style="color:#66d9ef">bool</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#f92672">...</span>
	<span style="color:#f92672">...</span>
	<span style="color:#f92672">...</span>
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unreachable&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
</code></pre></div><p>Okay function body copying is not what we searched for, let&rsquo;s try to improve existing jump implementation instead. Instead of <code>jump</code> replacement at the start of original body we could replace <code>jump</code> at the end of function body. Effectively we need to replace all existing <code>ret</code> instruction in original function body. With this implementation first original <code>mallocgc</code> function will be executed and then right after our patched decorator will be executed as well.</p>
<p><img loading="lazy" src="/monkey_patching_ret.png" alt="monkey patching ret"  />
</p>
<p>The problem with this idea is exactly the same as with idea before: the implementation requires to find all <code>ret</code> instructions which means parsing assembly. On top of this generally it&rsquo;s unsafe to replace <code>ret</code> instruction with our custom <code>jump</code> instruction because instructions have different sizes. This most likely will lead to replacing other unwanted code parts, not only desirable <code>ret</code> in <code>mallocgc</code>.</p>
<p>Okay so we 100% know now that we can&rsquo;t really deviate from <code>jump</code> at the start of the function. We also know that we need to execute both function bodies original and patch decorator, so just <code>jump</code> is not really suitable. Luckily we could try to use <code>call</code> instruction that does exactly what we need: <code>jump</code> to patch decorator, execute patch decorator, <code>jump</code> back to original place where it left it.</p>
<p><img loading="lazy" src="/monkey_patching_call.png" alt="monkey patching call"  />
</p>
<p>Sadly this also expectedly fails because original function body is destroyed by call replacement. By replacing instructions at the function top we are removing function stack setup logic <code>_runtime.morestack_noctxt</code> <a href="https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite">link</a>, so in reallity we can&rsquo;t directly patch function start. What we can try instead - find and patch a place near the top of <code>mallocgc</code> that has relatively &ldquo;unuseful&rdquo; code.</p>
<p><img loading="lazy" src="/mallocgc_replace_code1.png" alt="monkey replace code 1"  />
</p>
<p>The first check that verifies GC phase invariant and throws a panic, seems not 100% important to me. Panic basically means this piece of code should be unreachable 99.99(9)% of the normal execution time and probably could be sacrificed for our higher goal 😈. Let&rsquo;s take a look at <code>mallocgc</code> assembly one more time and calculate what bytes offset should be used to patch this exact check.</p>
<p><img loading="lazy" src="/mallocgc_assembly_guard1.png" alt="mallocgc assembly guard 1"  />
</p>
<p>Looks like for <code>amd64</code> architecture offset is 24 bytes. Let&rsquo;s modify existing <code>bouk/monkey</code> to use this offset and try again.</p>
<p><img loading="lazy" src="/monkey_patching_call_offset.png" alt="mallocgc patching call offset"  />
</p>
<p>As you can expect such patching doesn&rsquo;t work again. Currently, the problem is - we are patching only a part of original sacrificed <code>if block</code> which leaves random bytes artifacts right after patched code that can&rsquo;t be executed and leading to crash. Good for us it&rsquo;s easy enough to fix - what we need to pad our patch block with <code>nop</code> instructions to match original replaced block size.</p>
<p><img loading="lazy" src="/monkey_patching_call_offset_pad.png" alt="mallocgc patching call offset pad"  />
</p>
<p>Does it work this time? Yes, No, Not really???<br>
Basically with <code>call offset pad</code> method we&rsquo;ve almost achieved desired behavior, indeed decorator patch is called first and then original <code>mallocgc</code> body is executed (without first <code>if</code> block). The only slight issue our decorator doesn&rsquo;t receive proper <code>(size uintptr, tp *tp, needzero bool)</code> arguments. In fact it receives some sort of messed memory instead which redirects us to reading go function calling convention.</p>
<p>There are not a lot to say there: currently go uses stack based calling convention. There are some nice articles that gives you basic understanding of go calling convention basics <a href="https://dr-knz.net/go-calling-convention-x86-64.html">#1</a> <a href="https://cmc.gitbook.io/go-internals/chapter-i-go-assembly">#2</a>. Back to our issue in order to execute the call we need to use the calling convention, which means push the arguments to stack and update virtual stack pointer <code>SP</code> (the implementation for <code>amd64</code> is listed bellow).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># before call
</span><span style="color:#75715e"></span><span style="color:#a6e22e">sub</span> <span style="color:#66d9ef">rsp</span>,<span style="color:#ae81ff">0x28</span> <span style="color:#75715e"># allocate needed stack for call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rax</span>,<span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">rsp</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x30</span>] <span style="color:#75715e"># load argument 1 from the stack
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">rsp</span>],<span style="color:#66d9ef">rax</span> <span style="color:#75715e"># push argument 1 to the stack for call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">rax</span>,<span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">rsp</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x38</span>] <span style="color:#75715e"># load argument 2 from the stack
</span><span style="color:#75715e"></span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">rsp</span>],<span style="color:#66d9ef">rax</span> <span style="color:#75715e"># push argument 2 to the stack for call
</span><span style="color:#75715e"># execute call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">movabs</span> <span style="color:#66d9ef">rdx</span>, <span style="color:#66d9ef">PTR</span> <span style="color:#75715e"># load patch decorator address to call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">call</span> <span style="color:#66d9ef">QWORD</span> <span style="color:#66d9ef">PTR</span> [<span style="color:#66d9ef">rdx</span>] <span style="color:#75715e"># call patch decorator
</span><span style="color:#75715e"># after call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">add</span> <span style="color:#66d9ef">rsp</span>,<span style="color:#ae81ff">0x28</span> <span style="color:#75715e"># reset stack after call
</span><span style="color:#75715e"></span><span style="color:#66d9ef">sub</span> <span style="color:#66d9ef">rsp</span>,<span style="color:#ae81ff">0x98</span> <span style="color:#75715e"># reset stack to initial `mallogcgc` state
</span></code></pre></div><p>This implementation translates to 46 bytes for <code>amd64</code>, which unfortunately means we need more original <code>mallocgc</code> code to be sacrificed. Back to original <code>mallocgc</code> implementation we will need second <code>if</code> guard as well as first to cover patch size.</p>
<p><img loading="lazy" src="/mallocgc_replace_code2.png" alt="monkey replace code 2"  />
</p>
<p>The second check seems a bit more important than first one, although probably it just serves &ldquo;fast allocation code path&rdquo; and we can replace it too (anyhow we don&rsquo;t have any choice). All together first check + second check give us 53 bytes which is fine for us as we need only 46 bytes.</p>
<p><img loading="lazy" src="/mallocgc_assembly_guard2.png" alt="mallocgc assembly guard 2"  />
</p>
<p>Putting it all together and our patching started to work 🎉. I decided to put patching code to separate library <a href="https://github.com/1pkg/gomonkey">1pkg/gomonkey</a>, there are two reasons: patching described above needed for gotcha is really drifted away from original library and <code>bouk/monkey</code> is no longer supported by the author anyway.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// PermanentDecorate decorates function target call
</span><span style="color:#75715e">// with replacement function call by replacing
</span><span style="color:#75715e">// original function starting at offset with padding assembly bytes
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PermanentDecorate</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">r</span> <span style="color:#66d9ef">interface</span>{}, <span style="color:#a6e22e">offset</span>, <span style="color:#a6e22e">padding</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">before</span>, <span style="color:#a6e22e">after</span> []<span style="color:#66d9ef">byte</span>)
</code></pre></div><p>Note: despite that implementation above works, it&rsquo;s super unsafe. It uses code assumption about <code>mallocgc</code>, depends on calling convention that could be soon changed <a href="https://go.googlesource.com/proposal/+/master/design/27539-internal-abi.md">#1</a> <a href="https://go.googlesource.com/proposal/+/refs/changes/78/248178/1/design/40724-register-calling.md">#2</a>, uses platform specific machine code direcly, etc. This implementation isn&rsquo;t expected to work on anything apart from <code>amd64</code> with latest go runtime. Nevertheless, you can try to use or even improve this patching implementation at your own peril!</p>
<p>Finally, there are more possible ideas how to implement this patching even simpler potentially. As we did with full body copping, we can use third independent function holder to store not full original body copy this time but rather the only custom <code>jump</code> to the place right after original patch instruction, effectively doing double jump (this way we can try to avoid stack manipulations at all).</p>
<p><img loading="lazy" src="/monkey_patching_2jump.png" alt="monkey patching 2 jump"  />
</p>
<p>Or we could try to replace not important parts of original function body with full patch decorator body (if we manage to make it tiny enough) instead of <code>jump</code> (same restrictions as with full body copy). There are also definitely many other possible methods and solutions exist but not described in this article. Finally after playing long enough with different options and tricks, I decided to stick with working yet not ideal <code>call offset pad with stack</code>. I don&rsquo;t see any more benefits for gotcha to move forward with better patching methods for now because indeed patching is important part of the library but not its exclusive component. Also worth to mention that my poor assembly knowledge didn&rsquo;t help me on this way neither so if anyone has any good idea how to improve the patching, please let me know.</p>
<h3 id="goroutine-identifier---go-runtime-to-rescue">Goroutine identifier - go runtime to rescue<a hidden class="anchor" aria-hidden="true" href="#goroutine-identifier---go-runtime-to-rescue">#</a></h3>
<p>As we need to trace current memory consumption on goroutine basis. We need to have a mechanism to get a sort of unique identifier for any traced goroutine. Then using that we can instantiate global map where goroutine identifiers stored and act as keys and tracing object as values. Then on each <code>mallocgc</code> call in our hook function we need to look up the global map for current tracing object, if no object is found then create new tracing object and use it, then update the tracing object with a delta of newly allocated bytes, objects, calls.</p>
<p>Again as with other problems, need for goroutine local storage existed long before (especially in time before <code>context</code> conquered the go world). There are several opensource implementations to achieve the effect - I decided to go with <a href="https://github.com/modern-go/gls">modern-go/gls</a> because of nice and clean package interface. This package uses a runtime <a href="https://golang.org/doc/asm#x86">trick</a> to obtain a pointer to the current goroutine structure <code>runtime.g</code> then adds specific bytes offset to this pointer to access <code>goid</code> identifier field. By using this package, we now can trace each goroutine memory consumption separately which is what we wanted.</p>
<p>However, there is an issue with using <code>modern-go/gls</code> directly - it allocates memory (map operations inside library). Logically enough allocations inside <code>mallocgc</code> will call another <code>mallocgc</code> which in turn will call another <code>mallocgc</code> which in turn &hellip; infinite loop. What we need instead to have preallocated map on startup before patching and using this bound storage instead; by tweaking <code>modern-go/gls</code> we end up with tiny storage package <a href="https://github.com/1pkg/golocal">1pkg/golocal</a> that does single map allocation once, and works on bound storage further on (storage size could be tweaked by env variable). Also it&rsquo;s utilizing single rw mutex for locking which could cause some blocked allocations!!! Not really likely though as blocking operations <code>set</code> and <code>del</code> called extremely rare compared to nonblocking <code>get</code> that called on each given allocation.</p>
<h2 id="final-conclusion">Final conclusion<a hidden class="anchor" aria-hidden="true" href="#final-conclusion">#</a></h2>
<p>In final conclusion we can highlight that needs of accurate memory allocation tracing exists. It doesn&rsquo;t matter how good your languages tries to hide and abstract memory management, sometimes you just need to know memory consumptions and have some sort of handles to operate if memory consumption hits certain watermarks. Some of newer languages don&rsquo;t provide you any direct introspective tools or they are too limited or not granular enough, go is an example of such language. So decision was made to try to provide everybody with a comfy library that helps with granular memory tracing for go.</p>
<p>What makes go so special in my opinion is one of its greatest merit &ldquo;features and implementations conservatism&rdquo; but also it strikes back sometimes - there is no straightforward way how to override core golang rules (which is overall a good thing). But as always in real life, there is at least a single exception for any given rule. Going wild with number of those exceptions <a href="#unexported-function---golinkname-to-rescue">go linkname</a> <a href="#allocation-hooking---code-patching-to-rescue">code patching</a>
<a href="#goroutine-identifier---go-runtime-to-rescue">goroutine identifier</a> we are able to bend the rules but not break them.</p>
<p>In the end final gotcha implementation has reached its goals. It traces most of the memory allocations with certain precision and somewhat idiomatic and friendly interface. On the other hand restrictions that gotcha implies make its usage simply not worth it. So I highly discourage anyone to use gotcha in any production code or maybe even any code at all as it&rsquo;s extremely unsafe and not reliable and won&rsquo;t be supported in foreseeable future. Nevertheless, one could probably imagine reasonable use cases for this concept library in go benchmarks or test. Finally it&rsquo;s worth to say that primary intention to develop gotcha was learning and that gotcha doesn&rsquo;t have comprehensive tests coverage and support and not ready for any serious use case anyway. However, I hope you enjoyed the reading and understood the main idea of this article: &ldquo;despite you can adjust any generic piece to your specific needs if you try hard (especially with things that are designed in radically opposite way) it hardly worthy it in most of the cases; use specific solutions instead if you can&rdquo;.</p>


  </div>
  <footer class="post-footer">
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://1pkg.github.io">Kostinatyn Masliuk | 1pkg dev blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
