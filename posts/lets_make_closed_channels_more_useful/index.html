<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Let&#39;s make closed channels more useful | Kostinatyn Masliuk | 1pkg dev blog</title>

<meta name="keywords" content="" />
<meta name="description" content="Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of &ldquo;uninitialized variable&rdquo; errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures.">
<meta name="author" content="Kostiantyn Masliuk">
<link rel="canonical" href="https://1pkg.github.io/posts/lets_make_closed_channels_more_useful/" />
<link href="https://1pkg.github.io/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css" integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://1pkg.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://1pkg.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://1pkg.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://1pkg.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://1pkg.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.78.2" />


<meta property="og:title" content="Let&#39;s make closed channels more useful" />
<meta property="og:description" content="Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of &ldquo;uninitialized variable&rdquo; errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://1pkg.github.io/posts/lets_make_closed_channels_more_useful/" />
<meta property="article:published_time" content="2021-01-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-01-02T00:00:00+00:00" /><meta property="og:site_name" content="Kostinatyn Masliuk | 1pkg dev blog" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Let&#39;s make closed channels more useful"/>
<meta name="twitter:description" content="Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of &ldquo;uninitialized variable&rdquo; errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Let's make closed channels more useful",
  "name": "Let\u0027s make closed channels more useful",
  "description": "Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day ‚Ä¶",
  "keywords": [
    
  ],
  "articleBody": "Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of ‚Äúuninitialized variable‚Äù errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures. If you don‚Äôt know, there are some unsafe builtin zero nil value structures in go; namely most problematic ones are maps. But channels and slices could benefit from safe zero values as well. I‚Äôm not alone in my thoughts here, see one of such proposals of adding safer zero values to all builtin types. It‚Äôs pity that this was not foreseen originally, but I think now these changes can‚Äôt be introduced to runtime directly as they will break enormous amount of existing gocode and on top of that make existing code less efficient.\nRecently while I was working on gotcha - library for tracing allocated memory per goroutine, see my previous post. I figured that same ‚Äúpatching‚Äù technique could be also applied to a wide range of runtime modifications, e.g. we could try to change maps zero nil value to safer alternative or go even further and change some core operations semantic.\nChannels close semantic Channels are the single most important concurrent primitives in go. They are directly or indirectly used in a wide variety of tasks for any imaginable async communication between goroutines. They are first class citizen structures in go and go provides a special set of operations for them, like separate: send - and recv  operators, powerful select statement, builtin buffering, etc. Channels are great, but as everything inside go, they follow ‚Äúsimple by default‚Äù convection which strictly demands ‚Äúthe single way‚Äù of doing anything. It‚Äôs great rule usually, but sometimes it might be a bit inconvenient - for example when any given channel is closed, in receivers after receiving all buffered values from the channel all further ‚Äúclosed‚Äù values received from this channel will be empty zero values!\npackage main import \"fmt\" func main() { ch := make(chan int, 2) ch  100 close(ch) v, ok :=  ch fmt.Println(v, ok) // 100, true  v, ok =  ch fmt.Println(v, ok) // 0, false  v, ok =  ch fmt.Println(v, ok) // 0, false  v, ok =  ch fmt.Println(v, ok) // 0, false } Using default type zero value as ‚Äúclosed‚Äù channel value, again, is perfectly logical and valid approach and in most real world scenarios it works great. But sometimes an extra flexibility could simplify channel interactions. One of essential communication patterns - ‚Äúfanout‚Äù often is implemented via channel close call in go. This way it‚Äôs easy to make a ‚Äúfanout‚Äù signal for receivers but what is not that simple to deliver a message along with that signal, yet it‚Äôs simple enough to achieve the same effect with storing synchronized messages separately, although not that convenient. In my eyes, it might be an interesting idea to have a separate version of close called close2 in go with semantic close to this.\npackage main import \"fmt\" func main() { ch := make(chan int, 2) ch  100 close2(ch, 200) v, ok :=  ch fmt.Println(v, ok) // 100, true  v, ok =  ch fmt.Println(v, ok) // 200, false  v, ok =  ch fmt.Println(v, ok) // 200, false  v, ok =  ch fmt.Println(v, ok) // 200, false } I also understand that adding such specific tool inside go standard library is overkill and will lead only to unnecessary confusions, so separate library probably is an ideal place for such function.\nIntroduction of golatch library Meet golatch that seamlessly patches go runtime to provide a way to close a chan idempotently + overwrite empty value returned from that closed channel.\n  With Golatch  Without Golatch    package main import ( \"fmt\" \"sync\" \"github.com/1pkg/golatch\" ) func main() { ch := make(chan int) var wg sync.WaitGroup wg.Add(5) for i := 0; i 5; i++ { go worker(i, ch, \u0026wg) } golatch.Close(ch, 10) wg.Wait() } func worker(i int, ch chan int, wg *sync.WaitGroup) { v, ok :=  ch // 10, false \tif ok || v != 10 { panic(\"unreachable\") // won't panic \t} fmt.Printf(\"worker %d chan is closed with value %d\\n\", i, v) wg.Done() }    package main import ( \"fmt\" \"sync\" ) func main() { ch := make(chan int) var wg sync.WaitGroup wg.Add(5) for i := 0; i 5; i++ { go worker(i, ch, \u0026wg) } close(ch) wg.Wait() } func worker(i int, ch chan int, wg *sync.WaitGroup) { v, ok :=  ch // 0, false \tif ok || v != 10 { panic(\"unreachable\") // will panic \t} fmt.Printf(\"worker %d chan is closed with value %d\\n\", i, v) wg.Done() }    Golatch exposes single function Close that idempotently closes any provided channel and stores ‚Äúclosed‚Äù value for any further reading from that channel. When ‚Äúclosed‚Äù channel read occures default chan type zero value will be overwritten by previously stored ‚Äúclosed‚Äù value. Note that next calls to Close on the same channel will overwrite stored value with provided new value. Note also that Close returns Cancel eviction function that should be called in order to remove stored value and restore default receive behavior on the channel.\nHow does golatch even work? In order to understand what we need to do, we need to understand how go runtime handles channel receive and close in the first place. After some reading inside go runtime we can find next definitions.\n// entry points for //go:nosplit func chanrecv1(c *hchan, elem unsafe.Pointer) { chanrecv(c, elem, true) } //go:nosplit func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) { _, received = chanrecv(c, elem, true) return } //go:linkname reflect_chanrecv reflect.chanrecv func reflect_chanrecv(c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool) { return chanrecv(c, elem, !nb) } Those are chan receive entrypoint operations that we were searching for. Now the work is trivial - we just need to reflink and patch them, see my previous article for more info how this could be done. The basic idea of patched method is: reuse runtime helper chanrecv first, then check whether channel is closed or not, if channel is closed check whether any previous value for this channel was stored, if value is found in storage - overwrite default chan receive value and return this value instead. Luckily all those receive entrypoint functions are simply using chanrecv helper underneath so no extra patching effort unlike in gotcha is required.\ngomonkey.Patch(chanrecv1, (ch *hchan, elem unsafe.Pointer) { chanrecv(ch, elem, true) // apply any action only if chan is closed  if ch.closed { // if the store has relevant \"close\" value  if store.has(ch) { // get such value from the store  v := store.get(ch) // and set it to default return value  set(elem, v) } } }) As a mindful reader can notice we made just a half of job by patching chanrecv entrypoint methods. Indeed all receiving methods are done and any  expression will work as expected and return proper results, but what about select statement? After reading more code inside go runtime we can find next definitions for simple select cases.\n// compiler implements // //\tselect { //\tcase v = //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif selectnbrecv(\u0026v, c) { //\t... foo //\t} else { //\t... bar //\t} // func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected bool) { selected, _ = chanrecv(c, elem, false) return } // compiler implements // //\tselect { //\tcase v, ok = //\t... foo //\tdefault: //\t... bar //\t} // // as // //\tif c != nil \u0026\u0026 selectnbrecv2(\u0026v, \u0026ok, c) { //\t... foo //\t} else { //\t... bar //\t} // func selectnbrecv2(elem unsafe.Pointer, received *bool, c *hchan) (selected bool) { // TODO(khr): just return 2 values from this function, now that it is in Go. \tselected, *received = chanrecv(c, elem, false) return } And generic select entrypoint method as the cherry üçí on a pie ü•ß. I highly recommend you to read an additional excellent article on how channel operations work if you wanna understand select statement in depth.\n// selectgo implements the select statement. // // cas0 points to an array of type [ncases]scase, and order0 points to // an array of type [2*ncases]uint16 where ncases must be // Both reside on the goroutine's stack (regardless of any escaping in // selectgo). // // selectgo returns the index of the chosen scase, which matches the // ordinal position of its respective select{recv,send,default} call. // Also, if the chosen scase was a receive operation, it reports whether // a value was received. func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) Now we need to patch all those methods; patching selectnbrecv and selectnbrecv2 is quite an easy task, selectgo is on the other hand is much trickier. The simplest way to pass by - to use patch guard discussed in my previous post. One gotcha though, patch guard is unsafe to use; it‚Äôs not thread safe - while function code is unpatched back to original selectgo another selectgo call could happen in between, resulting in reading chan type zero value. This race could be quite awful, however I feel that for golatch use case patch guard advantages cleatly outweigh disadvantages and patch guard could be used as simplest solution. In anyway patching is generally a terrible unsafe idea and should NOT be used in any real code by anyone.\nFinal conclusion As with my previous article we can highlight that any thinkable language design change could be achieved (even change of core go semantic) if you dig deeply enough and agree to use some extreme techniques like go linkname and code patching. On the other hand while doing that, you should be constantly asking yourself - ‚Äúis it really worth doing so in a such wicked way?‚Äù. And I will argue that in most cases the answer is ‚Äúno‚Äù.\nAs I said previously the greatest merit of go ‚Äúfeatures and implementations conservatism‚Äù should always prevail; don‚Äôt fight your language instead embrace it. Nevertheless if you know what you are doing sometimes you can bend the rules and experiment even with the core concepts.\nIn my final conclusion I highly discourage anyone to use golatch in any production code or maybe even any code at all as it‚Äôs extremely unsafe and not reliable and won‚Äôt be supported in foreseeable future. Nevertheless, one could probably imagine reasonable use cases for this concept library in go benchmarks or test. Finally it‚Äôs worth to say that primary intention to develop golatch was learning and that golatch doesn‚Äôt have comprehensive tests coverage and support and not ready for any serious use case anyway.\n",
  "wordCount" : "1822",
  "inLanguage": "en",
  "datePublished": "2021-01-02T00:00:00Z",
  "dateModified": "2021-01-02T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Kostiantyn Masliuk"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://1pkg.github.io/posts/lets_make_closed_channels_more_useful/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kostinatyn Masliuk | 1pkg dev blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://1pkg.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="single" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://1pkg.github.io" accesskey="h">~</a>
            <span class="logo-switches">
                <span class="theme-toggle">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Let&#39;s make closed channels more useful
    </h1>
    <div class="post-meta">

January 2, 2021&nbsp;¬∑&nbsp;Kostiantyn Masliuk

    </div>
  </header> 

  <div class="post-content">
<h2 id="go-zero-values">Go zero values<a hidden class="anchor" aria-hidden="true" href="#go-zero-values">#</a></h2>
<p>Zero values is an extremely useful feature of golang, you can read <a href="https://dave.cheney.net/2013/01/19/what-is-the-zero-value-and-why-is-it-useful">nice detailed article</a> about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of &ldquo;uninitialized variable&rdquo; errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures. If you don&rsquo;t know, there are some unsafe builtin zero <code>nil</code> value structures in go; namely most problematic ones are maps. But channels and slices could benefit from safe zero values as well. I&rsquo;m not alone in my thoughts here, see <a href="https://github.com/golang/go/issues/28133">one of such proposals</a> of adding safer zero values to all builtin types. It&rsquo;s pity that this was not foreseen originally, but I think now these changes can&rsquo;t be introduced to runtime directly as they will break enormous amount of existing gocode and on top of that make existing code less efficient.</p>
<p>Recently while I was working on <a href="https://github.com/1pkg/gotcha"><code>gotcha</code></a> - library for tracing allocated memory per goroutine, see <a href="/posts/lets_trace_goroutine_allocated_memory/">my previous post</a>. I figured that same &ldquo;patching&rdquo; technique could be also applied to a wide range of runtime modifications, e.g. we could try to change maps zero <code>nil</code> value to safer alternative or go even further and change some core operations semantic.</p>
<h2 id="channels-close-semantic">Channels close semantic<a hidden class="anchor" aria-hidden="true" href="#channels-close-semantic">#</a></h2>
<p>Channels are the single most important concurrent primitives in go. They are directly or indirectly used in a wide variety of tasks for any imaginable async communication between goroutines. They are first class citizen structures in go and go provides a special set of operations for them, like separate: <code>send -&gt;</code> and <code>recv &lt;-</code> operators, powerful <code>select</code> statement, builtin buffering, etc. Channels are great, but as everything inside go, they follow &ldquo;simple by default&rdquo; convection which strictly demands &ldquo;the single way&rdquo; of doing anything. It&rsquo;s great rule usually, but sometimes it might be a bit inconvenient - for example when any given channel is closed, in receivers after receiving all buffered values from the channel all further &ldquo;closed&rdquo; values received from this channel will be empty zero values!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">100</span>
    close(<span style="color:#a6e22e">ch</span>)
    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 100, true
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 0, false
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 0, false
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 0, false
</span><span style="color:#75715e"></span>}
</code></pre></div><p>Using default type zero value as &ldquo;closed&rdquo; channel value, again, is perfectly logical and valid approach and in most real world scenarios it works great. But sometimes an extra flexibility could simplify channel interactions. One of essential communication patterns - &ldquo;fanout&rdquo; often is implemented via channel close call in go. This way it&rsquo;s easy to make a &ldquo;fanout&rdquo; signal for receivers but what is not that simple to deliver a message along with that signal, yet it&rsquo;s simple enough to achieve the same effect with storing synchronized messages separately, although not that convenient. In my eyes, it might be an interesting idea to have a separate version of <code>close</code> called <code>close2</code> in go with semantic close to this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">100</span>
    <span style="color:#a6e22e">close2</span>(<span style="color:#a6e22e">ch</span>, <span style="color:#ae81ff">200</span>)
    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 100, true
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 200, false
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 200, false
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span>) <span style="color:#75715e">// 200, false
</span><span style="color:#75715e"></span>}
</code></pre></div><p>I also understand that adding such specific tool inside go standard library is overkill and will lead only to unnecessary confusions, so separate library probably is an ideal place for such function.</p>
<h2 id="introduction-of-golatch-library">Introduction of golatch library<a hidden class="anchor" aria-hidden="true" href="#introduction-of-golatch-library">#</a></h2>
<p>Meet <a href="https://github.com/1pkg/golatch">golatch</a> that seamlessly patches go runtime to provide a way to close a chan idempotently + overwrite empty value returned from that closed channel.</p>
<table>
<tr>
<th>With Golatch</th>
<th></th>
<th>Without Golatch</th>
</tr>
<tr>
<td>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;sync&#34;</span>

	<span style="color:#e6db74">&#34;github.com/1pkg/golatch&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">5</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">ch</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
	}
	<span style="color:#a6e22e">golatch</span>.<span style="color:#a6e22e">Close</span>(<span style="color:#a6e22e">ch</span>, <span style="color:#ae81ff">10</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
	<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span> <span style="color:#75715e">// 10, false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span> {
		panic(<span style="color:#e6db74">&#34;unreachable&#34;</span>) <span style="color:#75715e">// won&#39;t panic
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker %d chan is closed with value %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}
</code></pre></div></td>
<td></td>
<td>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
	<span style="color:#e6db74">&#34;fmt&#34;</span>
	<span style="color:#e6db74">&#34;sync&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">5</span>)
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">ch</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
	}
	close(<span style="color:#a6e22e">ch</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">worker</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
	<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">ch</span> <span style="color:#75715e">// 0, false
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">10</span> {
		panic(<span style="color:#e6db74">&#34;unreachable&#34;</span>) <span style="color:#75715e">// will panic
</span><span style="color:#75715e"></span>	}
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;worker %d chan is closed with value %d\n&#34;</span>, <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">v</span>)
	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
}


</code></pre></div></td>
</tr>
</table>
<p>Golatch exposes single function <code>Close</code> that idempotently closes any provided channel and stores &ldquo;closed&rdquo; value for any further reading from that channel. When &ldquo;closed&rdquo; channel read occures default chan type zero value will be overwritten by previously stored &ldquo;closed&rdquo; value. Note that next calls to <code>Close</code> on the same channel will overwrite stored value with provided new value. Note also that <code>Close</code> returns <code>Cancel</code> eviction function that should be called in order to remove stored value and restore default receive behavior on the channel.</p>
<h2 id="how-does-golatch-even-work">How does golatch even work?<a hidden class="anchor" aria-hidden="true" href="#how-does-golatch-even-work">#</a></h2>
<p>In order to understand what we need to do, we need to understand how go runtime handles channel receive and close in the first place. After some reading inside go runtime we can find next definitions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// entry points for &lt;- c from compiled code
</span><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chanrecv1</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) {
	<span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">true</span>)
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//go:nosplit
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">chanrecv2</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) (<span style="color:#a6e22e">received</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">received</span> = <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">true</span>)
	<span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">//go:linkname reflect_chanrecv reflect.chanrecv
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reflect_chanrecv</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">nb</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) (<span style="color:#a6e22e">selected</span> <span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">received</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">elem</span>, !<span style="color:#a6e22e">nb</span>)
}
</code></pre></div><p>Those are chan receive entrypoint operations that we were searching for. Now the work is trivial - we just need to reflink and patch them, see my <a href="/posts/lets_trace_goroutine_allocated_memory/">previous article</a> for more info how this could be done. The basic idea of patched method is: reuse runtime helper <code>chanrecv</code> first, then check whether channel is closed or not, if channel is closed check whether any previous value for this channel was stored, if value is found in storage - overwrite default chan receive value and return this value instead. Luckily all those receive entrypoint functions are simply using <code>chanrecv</code> helper underneath so no extra patching effort unlike in <a href="https://github.com/1pkg/gotcha">gotcha</a> is required.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">gomonkey</span>.<span style="color:#a6e22e">Patch</span>(<span style="color:#a6e22e">chanrecv1</span>, (<span style="color:#a6e22e">ch</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>, <span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) {
    <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">ch</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">true</span>)
    <span style="color:#75715e">// apply any action only if chan is closed
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span>.<span style="color:#a6e22e">closed</span> {
        <span style="color:#75715e">// if the store has relevant &#34;close&#34; value
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">store</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">ch</span>) {
            <span style="color:#75715e">// get such value from the store
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">store</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">ch</span>)
            <span style="color:#75715e">// and set it to default return value
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">v</span>)
        }
    }
})
</code></pre></div><p>As a mindful reader can notice we made just a half of job by patching <code>chanrecv</code> entrypoint methods. Indeed all receiving methods are done and any <code>&lt;-</code> expression will work as expected and return proper results, but what about <code>select</code> statement? After reading more code inside go runtime we can find next definitions for simple <code>select</code> cases.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// compiler implements
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//	select {
</span><span style="color:#75715e">//	case v = &lt;-c:
</span><span style="color:#75715e">//		... foo
</span><span style="color:#75715e">//	default:
</span><span style="color:#75715e">//		... bar
</span><span style="color:#75715e">//	}
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// as
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//	if selectnbrecv(&amp;v, c) {
</span><span style="color:#75715e">//		... foo
</span><span style="color:#75715e">//	} else {
</span><span style="color:#75715e">//		... bar
</span><span style="color:#75715e">//	}
</span><span style="color:#75715e">//
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectnbrecv</span>(<span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>) (<span style="color:#a6e22e">selected</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#a6e22e">selected</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">false</span>)
	<span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// compiler implements
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//	select {
</span><span style="color:#75715e">//	case v, ok = &lt;-c:
</span><span style="color:#75715e">//		... foo
</span><span style="color:#75715e">//	default:
</span><span style="color:#75715e">//		... bar
</span><span style="color:#75715e">//	}
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// as
</span><span style="color:#75715e">//
</span><span style="color:#75715e">//	if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) {
</span><span style="color:#75715e">//		... foo
</span><span style="color:#75715e">//	} else {
</span><span style="color:#75715e">//		... bar
</span><span style="color:#75715e">//	}
</span><span style="color:#75715e">//
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectnbrecv2</span>(<span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">received</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">bool</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hchan</span>) (<span style="color:#a6e22e">selected</span> <span style="color:#66d9ef">bool</span>) {
	<span style="color:#75715e">// TODO(khr): just return 2 values from this function, now that it is in Go.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">selected</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">received</span> = <span style="color:#a6e22e">chanrecv</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#66d9ef">false</span>)
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><p>And generic select entrypoint method as the cherry üçí on a pie ü•ß.
I highly recommend you to read an additional <a href="https://programming.vip/docs/deeply-understanding-the-principles-of-go-channel-and-select.html">excellent article</a> on how channel operations work if you wanna understand <code>select</code> statement in depth.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// selectgo implements the select statement.
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// cas0 points to an array of type [ncases]scase, and order0 points to
</span><span style="color:#75715e">// an array of type [2*ncases]uint16 where ncases must be &lt;= 65536.
</span><span style="color:#75715e">// Both reside on the goroutine&#39;s stack (regardless of any escaping in
</span><span style="color:#75715e">// selectgo).
</span><span style="color:#75715e">//
</span><span style="color:#75715e">// selectgo returns the index of the chosen scase, which matches the
</span><span style="color:#75715e">// ordinal position of its respective select{recv,send,default} call.
</span><span style="color:#75715e">// Also, if the chosen scase was a receive operation, it reports whether
</span><span style="color:#75715e">// a value was received.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">selectgo</span>(<span style="color:#a6e22e">cas0</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">scase</span>, <span style="color:#a6e22e">order0</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uint16</span>, <span style="color:#a6e22e">ncases</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">bool</span>)
</code></pre></div><p>Now we need to patch all those methods; patching <code>selectnbrecv</code> and <code>selectnbrecv2</code> is quite an easy task, <code>selectgo</code> is on the other hand is much trickier. The simplest way to pass by - to use patch guard discussed in my <a href="/posts/lets_trace_goroutine_allocated_memory/">previous post</a>. One gotcha though, patch guard is unsafe to use; it&rsquo;s not thread safe - while function code is unpatched back to original <code>selectgo</code> another <code>selectgo</code> call could happen in between, resulting in reading chan type zero value. This race could be quite awful, however I feel that for golatch use case patch guard advantages cleatly outweigh disadvantages and patch guard could be used as simplest solution. In anyway patching is generally a terrible unsafe idea and should NOT be used in any real code by anyone.</p>
<h2 id="final-conclusion">Final conclusion<a hidden class="anchor" aria-hidden="true" href="#final-conclusion">#</a></h2>
<p>As with my <a href="/posts/lets_trace_goroutine_allocated_memory/">previous article</a> we can highlight that any thinkable language design change could be achieved (even change of core go semantic) if you dig deeply enough and agree to use some extreme techniques like <a href="/posts/lets_trace_goroutine_allocated_memory/#unexported-function---golinkname-to-rescue">go linkname</a> and <a href="/posts/lets_trace_goroutine_allocated_memory/#allocation-hooking---code-patching-to-rescue">code patching</a>. On the other hand while doing that, you should be constantly asking yourself - &ldquo;is it really worth doing so in a such wicked way?&rdquo;. And I will argue that in most cases the answer is &ldquo;no&rdquo;.</p>
<p>As I said previously the greatest merit of go ‚Äúfeatures and implementations conservatism‚Äù should always prevail; don&rsquo;t fight your language instead embrace it. Nevertheless if you know what you are doing sometimes you can bend the rules and experiment even with the core concepts.</p>
<p>In my final conclusion I highly discourage anyone to use golatch in any production code or maybe even any code at all as it‚Äôs extremely unsafe and not reliable and won‚Äôt be supported in foreseeable future. Nevertheless, one could probably imagine reasonable use cases for this concept library in go benchmarks or test. Finally it&rsquo;s worth to say that primary intention to develop golatch was learning and that golatch doesn&rsquo;t have comprehensive tests coverage and support and not ready for any serious use case anyway.</p>

</div>
  <footer class="post-footer">
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://1pkg.github.io">Kostinatyn Masliuk | 1pkg dev blog</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top" accesskey="g">
    <button class="top-link" id="top-link" type="button">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6">
            <path d="M12 6H0l6-6z" /></svg>
    </button>
</a>



<script defer src="https://1pkg.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                behavior: "smooth"
            });
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
