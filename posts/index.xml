<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Kostinatyn Masliuk | 1pkg dev blog</title>
    <link>https://1pkg.github.io/posts/</link>
    <description>Recent content in Posts on Kostinatyn Masliuk | 1pkg dev blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://1pkg.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implementing go ambiguous operator</title>
      <link>https://1pkg.github.io/posts/implementing_go_ambiguous_operator/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://1pkg.github.io/posts/implementing_go_ambiguous_operator/</guid>
      <description>Lately, I discovered one great tech blog https://tpaschalis.github.io. One of the articles that caught my eye was amb operator in golang. In my opinion, ambigious operator is brilliant concept in scope of elegant functional programming. Ambiguous operator is defined by its author John McCarthy as
Ambiguous functions: Functions whose value are incompletely specified. May be useful in providing facts about functions where certain details are irrelevant to the statement being proved.</description>
    </item>
    
    <item>
      <title>Writing complex concurrent table driven tests</title>
      <link>https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://1pkg.github.io/posts/writing_complex_concurrent_table_driven_tests/</guid>
      <description>Recently, I&amp;rsquo;ve finished my reading of &amp;ldquo;Software Engineering at Google&amp;rdquo; book. Despite the fact that this book contains considerable amount of: information duplicity, obvious advices and quite generic explanations. I still can suggest this book to anyone interested in understanding the modern Software Engineering industry. Although be advised that book doesn&amp;rsquo;t go very deep with any given topic. Rather, it&amp;rsquo;s just quite nicely composed collection of easy to read and understand thoughts from Google engineers.</description>
    </item>
    
    <item>
      <title>Private repository dependency management with gomod</title>
      <link>https://1pkg.github.io/posts/private_repository_dependency_management_with_gomod/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://1pkg.github.io/posts/private_repository_dependency_management_with_gomod/</guid>
      <description>According to go survey 2020, gomod has finally won long disputes around dependency management in go: &amp;ldquo;Go modules adoption is nearly universal with 77% satisfaction, but respondents also highlight a need for improved docs&amp;rdquo;. This is not surprising at all, as it is indeed a solid tool, but even more importantly, included into default go distribution as the official dependency management tool. With that said, gomod is not ideal (as any other complex tool) sometimes you can stumble upon some controversial decisions or need to know some internal implementation details to use it properly in some less common setups.</description>
    </item>
    
    <item>
      <title>Let&#39;s make closed channels more useful</title>
      <link>https://1pkg.github.io/posts/lets_make_closed_channels_more_useful/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://1pkg.github.io/posts/lets_make_closed_channels_more_useful/</guid>
      <description>Go zero values Zero values is an extremely useful feature of golang, you can read nice detailed article about why they are so important. They are not only making day to day programming simpler but also save everyone from whole layer of &amp;ldquo;uninitialized variable&amp;rdquo; errors specific to languages like C. Personally I think that it would be beneficial if go could provide us with more useful safe zero value for all builtin structures.</description>
    </item>
    
    <item>
      <title>Let&#39;s trace goroutine allocated memory</title>
      <link>https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/</link>
      <pubDate>Tue, 08 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://1pkg.github.io/posts/lets_trace_goroutine_allocated_memory/</guid>
      <description>Memory tracing retrospective On the dawn of computer era, every allocated piece of memory was properly accounted by a programmer, it was not possible otherwise as memory was limited and precious fundamental resource. Memory is no less fundamental resource nowadays but with its exponential growth per single machine; trend of adding more high level memory management abstractions bloomed. In languages like C it&amp;rsquo;s rather easy to calculate exact amount of memory allocated (you fully control all heap allocation by yourself), on the other hand it&amp;rsquo;s not that simple in languages like Go that are hiding memory management details inside runtime abstractions.</description>
    </item>
    
  </channel>
</rss>
